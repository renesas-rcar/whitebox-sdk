From 7fb98c7dcc36e28a3b3cfe67680a40ed8171b457 Mon Sep 17 00:00:00 2001
From: Tsutomu Muroya <tsutomu.muroya.jy@bp.renesas.com>
Date: Fri, 29 Sep 2023 12:22:22 +0900
Subject: [PATCH] trampoline: Sample Projects Added

-iccom and Benchmark integrated

Signed-off-by: Tsutomu Muroya <tsutomu.muroya.jy@bp.renesas.com>
---
 examples/renesas/sample/benchmark.c           |  92 ++++++++
 examples/renesas/sample/build.sh              |  17 ++
 .../sample/cs_plus_rcar_download_all.py       |  37 +++
 examples/renesas/sample/goto_reset.py         |   9 +
 examples/renesas/sample/iccom.c               | 220 ++++++++++++++++++
 examples/renesas/sample/iccom.h               |  10 +
 examples/renesas/sample/iccom_commands.h      |  66 ++++++
 examples/renesas/sample/iccom_ll.c            | 169 ++++++++++++++
 examples/renesas/sample/iccom_ll.h            |  42 ++++
 examples/renesas/sample/sample.oil            |  72 ++++++
 10 files changed, 734 insertions(+)
 create mode 100644 examples/renesas/sample/benchmark.c
 create mode 100644 examples/renesas/sample/build.sh
 create mode 100644 examples/renesas/sample/cs_plus_rcar_download_all.py
 create mode 100644 examples/renesas/sample/goto_reset.py
 create mode 100644 examples/renesas/sample/iccom.c
 create mode 100644 examples/renesas/sample/iccom.h
 create mode 100644 examples/renesas/sample/iccom_commands.h
 create mode 100644 examples/renesas/sample/iccom_ll.c
 create mode 100644 examples/renesas/sample/iccom_ll.h
 create mode 100644 examples/renesas/sample/sample.oil

diff --git a/examples/renesas/sample/benchmark.c b/examples/renesas/sample/benchmark.c
new file mode 100644
index 00000000..6dc17d9a
--- /dev/null
+++ b/examples/renesas/sample/benchmark.c
@@ -0,0 +1,92 @@
+#include "tpl_os.h"
+
+#define APP_Task_blink_START_SEC_CODE
+#include "tpl_memmap.h"
+
+uint8 shared_memory[16][16];
+uint8 result_array[4][17];
+
+uint32 g_counter = 0;
+
+extern volatile TickType tpl_time_counter; // 10msec/count 
+#define TICK_TO_MSEC(t)	(t*10)
+#define TICK_TO_SEC(t)	(t/100)
+
+/**
+ * external functions
+ */
+extern void dhrystone_main(void);
+extern void coremark_main(void);
+
+void float_to_char(uint8 input_array[], float input) {
+	uint8 i, n;
+	uint8 ascii_offset = 0x20; // 0x30 = '0' / 0x20 = ' '
+	float tmp;
+
+	for (i=0; i<16; ++i){
+		tmp = input;
+		if (i < 8) {
+			for(n=i+1; n<8;++n)
+				tmp = tmp / 10;
+		}
+		else {
+			for(n=7; n<i; ++n)
+				tmp = tmp * 10;
+		}
+
+		if((int)tmp%10 != 0 || i == 7)
+			ascii_offset = 0x30; // changed at once
+
+		input_array[i+(i/8)] = (ascii_offset + (int)tmp%10); // if (i==8) i+1, else i
+	}
+	input_array[8] = '.';
+	input_array[16] = '\0';
+}
+void int_to_char(uint8 input_array[], int input) {
+uint8 i, n;
+uint8 ascii_offset = 0x20; // 0x30 = '0' / 0x20 = ' '
+int tmp;
+
+	for (i=0; i<16; ++i){
+		tmp = input;
+		for(n=i+1; n<16;++n)
+			tmp = tmp / 10;
+		if((int)tmp%10 != 0)
+ 			ascii_offset = 0x30; // changed at once
+
+		input_array[i] = (ascii_offset + (int)tmp%10); // if (i==8) i+1, else i
+	}
+}
+
+// return msec
+uint32 ms_time() { return TICK_TO_MSEC(tpl_time_counter); }
+// return sec
+uint32 time() { return TICK_TO_SEC(tpl_time_counter); }
+
+void sec_sleep(int sec)
+{
+	uint32 end;
+	end = time() + sec;
+	while(end > time());
+}
+
+void ms_sleep(int ms)
+{
+	uint32 end;
+	end = ms_time() + ms;
+	while(end > ms_time());
+}
+
+
+void benchmark()
+{
+	dhrystone_main();
+	ms_sleep(100);
+
+	coremark_main();
+	sec_sleep(1);
+
+}
+
+#define APP_Task_blink_STOP_SEC_CODE
+#include "tpl_memmap.h"
diff --git a/examples/renesas/sample/build.sh b/examples/renesas/sample/build.sh
new file mode 100644
index 00000000..cea8f192
--- /dev/null
+++ b/examples/renesas/sample/build.sh
@@ -0,0 +1,17 @@
+#!/usr/bin/env bash
+
+#stop on errors
+set -e
+
+if [[ ! -d "_build" ]]
+then
+    mkdir _build
+fi
+
+echo "*** Run Goil ***"
+goil --target=renesas/g4mh --templates=../../../goil/templates/ sample.oil
+cd _build
+echo "*** Run CMake ***"
+cmake -G "Unix Makefiles" -D CMAKE_TOOLCHAIN_FILE=../sample/compiler.cmake ..
+echo "*** Run Make ***"
+make
diff --git a/examples/renesas/sample/cs_plus_rcar_download_all.py b/examples/renesas/sample/cs_plus_rcar_download_all.py
new file mode 100644
index 00000000..9de4d4e3
--- /dev/null
+++ b/examples/renesas/sample/cs_plus_rcar_download_all.py
@@ -0,0 +1,37 @@
+﻿
+import time
+ClearConsole()
+print "1PE_ATK2"
+print "Resetting debugger"
+debugger.Reset()
+time.sleep(2)
+print "SYSCTRL 0x0003"
+debugger.Register.SetValue("SYSCTRL.BOOTCTRL", 0x0003)
+time.sleep(2)
+print "CPU Stop"
+debugger.Stop()
+time.sleep(2)
+print "HBG_CS 0x00000003"
+debugger.Register.SetValue("HBG_CS0.HBGPROT0", 0x00000003)
+debugger.Register.SetValue("HBG_CS1.HBGPROT0", 0x00000003)
+debugger.Register.SetValue("HBG_CS2.HBGPROT0", 0x00000003)
+#time.sleep(1)
+print "CSRM 0x12B9B0A0"
+debugger.Register.SetValue("CSRM0.CSRM0CSIFCODE", 0x12B9B0A0)
+debugger.Register.SetValue("CSRM1.CSRM1CSIFCODE", 0x12B9B0A0)
+debugger.Register.SetValue("CSRM2.CSRM2CSIFCODE", 0x12B9B0A0)
+#time.sleep(1)
+print "Download Trampoline/Hello_world"
+debugger.Download.LoadModule("_build/iccom_exe.abs", downloadOption = DownloadOption.SymbolOnly, append = False, flashErase = False, vendorType = VendorType.Auto)
+print "Download Trampoline/Hello_world (RUN)"
+debugger.Download.Hex("_build/iccom_exe.run", offset = 0xF0000000, append = True, flashErase = False)
+print "CSRM 0x12B9B0A1"
+debugger.Register.SetValue("CSRM0.CSRM0CSIFCODE", 0x12B9B0A1)
+debugger.Register.SetValue("CSRM1.CSRM1CSIFCODE", 0x12B9B0A1)
+debugger.Register.SetValue("CSRM2.CSRM2CSIFCODE", 0x12B9B0A1)
+#time.sleep(1)
+print "Set Reset PC"
+debugger.Register.SetValue("PC", 0x200)
+#time.sleep(1)
+print "Starting G4"
+debugger.Go()
diff --git a/examples/renesas/sample/goto_reset.py b/examples/renesas/sample/goto_reset.py
new file mode 100644
index 00000000..d8b91370
--- /dev/null
+++ b/examples/renesas/sample/goto_reset.py
@@ -0,0 +1,9 @@
+﻿import time
+ClearConsole()
+
+debugger.Stop()
+time.sleep(2)
+
+print "Set Reset PC"
+debugger.Register.SetValue("PC", 0x200)
+
diff --git a/examples/renesas/sample/iccom.c b/examples/renesas/sample/iccom.c
new file mode 100644
index 00000000..886e30a2
--- /dev/null
+++ b/examples/renesas/sample/iccom.c
@@ -0,0 +1,220 @@
+#include "tpl_os.h"
+#include "iccom.h"
+#include "iccom_ll.h"
+#include "iccom_commands.h"
+
+#define APP_Task_iccom_START_SEC_CODE
+#include "tpl_memmap.h"
+
+#include "iccom_commands.h"
+
+extern volatile VAR(uint32, OS_VAR) tpl_time_counter;
+extern void benchmark();
+
+/* ICCOM protocol */
+enum ICCOM_MSG {
+	ICCOM_MSG_INVALID,
+	ICCOM_MSG_INIT,
+	ICCOM_MSG_DATA,
+	ICCOM_MSG_ACK
+};
+
+#define ICCOM_BUF_MAX_SIZE		(TOTAL_CTA_SIZE/2)
+#define TIMER_TICK_INTERVAL_NS		(125U)
+#define TIMER_TICKS_PER_MS		(1000000U/TIMER_TICK_INTERVAL_NS)
+#define HOST_INT_CLEAR_TIMEOUT_MS	(500U*TIMER_TICKS_PER_MS)
+#define OS_NAME				"Trampoline"
+#define OS_NAME_SIZE			10
+#define BENCH_SIZE			(17*14+1)
+#define BENCH_TOTAL_SIZE		BENCH_SIZE*2+1
+uint8 iccom_initalized = 0;
+struct echo_command recv_pkt;
+char bench_total[BENCH_TOTAL_SIZE];
+char bench_buf[BENCH_SIZE];
+char bench_buf2[BENCH_SIZE];
+
+static void iccom_notify_tx_data(size_t message)
+{
+	iccom_set_out_msg_reg((uint32)message);
+	iccom_set_out_ctrl_reg(ICCOM_HW_CONTROL_INIT);
+	iccom_set_out_ctrl_reg(ICCOM_CTRL_DATA | ICCOM_CTRL_BUFF_UPPER | ICCOM_CTRL_INT);
+}
+
+static void iccom_send_rx_data_ack(uint32 message)
+{
+	iccom_set_out_msg_reg(message);
+	iccom_set_out_ctrl_reg(ICCOM_CTRL_ACK | ICCOM_CTRL_BUFF_BOTTOM | ICCOM_CTRL_INT);
+	// iccom_set_out_ctrl_reg(ICCOM_CTRL_ACK | ICCOM_CTRL_BUFF_UPPER | ICCOM_CTRL_INT);
+}
+
+static void iccom_send_initialization_ack(void)
+{
+	iccom_set_out_ctrl_reg(ICCOM_CTRL_INIT_COMPLETED | ICCOM_CTRL_INT);
+}
+
+static sint32 iccom_wait_for_out_interrupt_clear(uint32_t timeout_ms)
+{
+	uint32 out_ctrl_reg;
+	TickType start_val, curr_val;
+
+	start_val = tpl_time_counter;
+	do {
+		iccom_get_out_ctrl_reg(&out_ctrl_reg);
+		curr_val = tpl_time_counter;
+		// If the host processor doesn't clear the interrupt before the timeout
+		// then it's likely that the host application stopped/crashed and this
+		// clear will never happen. So we clear it on our side and return an
+		// error
+		if (curr_val - start_val > timeout_ms) {
+			iccom_set_out_ctrl_reg(ICCOM_HW_CONTROL_INIT);
+			return -1;
+		}
+	} while (out_ctrl_reg & ICCOM_CTRL_INT);
+
+	return 0;
+}
+
+static void iccom_send(uint8* data, size_t size, uint8_t copy_to_out_cta)
+{
+	// If this function is called with data already on the CTA buffer,
+	// then there is no need to update it
+	if (copy_to_out_cta) {
+		iccom_cta_write(data, size);
+	}
+	iccom_notify_tx_data(size);
+}
+
+static void iccom_handle_rx_msg(size_t size)
+{
+	struct command_header* in_pkt;
+	sint32 ret;
+
+	// Casting to the most simple structure in order to get the "cmd_id".
+	// Later the proper casting will be done
+	in_pkt = (struct command_header*) iccom_get_read_cta_ptr();
+	// copy packet before sending ACK
+	memcpy(&recv_pkt, in_pkt, size);
+	//recv_pkt.cmd_id = in_pkt->cmd_id;
+	iccom_send_rx_data_ack((uint32)size);
+	ret = iccom_wait_for_out_interrupt_clear(HOST_INT_CLEAR_TIMEOUT_MS);
+	if (ret < 0) {
+		// In case of timeout then there's no reason to process the answer
+		// further since the host processor will not care about this 
+		goto Exit;
+	}
+
+	switch (in_pkt->cmd_id) {
+		case NONE: {
+			// Nothing to do
+			break;
+		}
+
+		case BENCH: {
+			struct echo_reply* reply_pkt = iccom_cta_write_cta_ptr();
+
+			// Just copy the data back
+			benchmark();
+			sprintf(bench_total, "%s%s", bench_buf, bench_buf2);
+			memcpy(reply_pkt, bench_total, BENCH_TOTAL_SIZE);
+			iccom_send((uint8*)reply_pkt, BENCH_TOTAL_SIZE, 0);
+			break;
+		}
+
+		case ECHO: {
+			struct echo_reply* reply_pkt = iccom_cta_write_cta_ptr();
+
+			// Just copy the data back
+			memcpy(reply_pkt, &recv_pkt, size);
+			iccom_send((uint8*)reply_pkt, size, 0);
+			break;
+		}
+
+		case OS: {
+			struct echo_reply* reply_pkt = iccom_cta_write_cta_ptr();
+			memcpy(reply_pkt, OS_NAME, OS_NAME_SIZE);
+			iccom_send((uint8*)reply_pkt, OS_NAME_SIZE, 0);
+			break;
+		}
+
+		default:
+			break;
+	}
+Exit:
+	;
+}
+
+static void iccom_handle_ack_received(void)
+{
+	iccom_set_in_ctrl_reg(ICCOM_HW_CONTROL_INIT);
+}
+
+enum ICCOM_MSG iccom_get_msg_type(uint32 control)
+{
+	if (control & ICCOM_CTRL_INIT_COMPLETED)
+		return ICCOM_MSG_INIT;
+	if (control & ICCOM_CTRL_DATA)
+		return ICCOM_MSG_DATA;
+	else
+		return ICCOM_MSG_ACK;
+}
+
+void iccom_init(void)
+{
+	/* Initialize the HW first*/
+	iccom_ll_init();
+	/* clear control register */
+	iccom_set_out_ctrl_reg(ICCOM_HW_CONTROL_INIT);
+	/* clear message register */
+	iccom_set_out_msg_reg(0x00000000UL);
+}
+
+FUNC(int, OS_APPL_CODE) main(void)
+{
+	iccom_init();
+	StartOS(OSDEFAULTAPPMODE);
+	return 0;
+}
+
+TASK(iccom) {
+}
+
+ISR(iccomInt)
+{
+	uint32 target_control = 0;
+	uint32 target_message = 0;
+	size_t rx_size = 0;
+
+	iccom_get_in_ctrl_reg(&target_control);
+	iccom_get_in_msg_reg(&target_message);
+
+	switch (iccom_get_msg_type(target_control)) {
+	case ICCOM_MSG_DATA:
+		rx_size = (size_t)target_message;
+		if (rx_size > ICCOM_BUF_MAX_SIZE)
+			rx_size = ICCOM_BUF_MAX_SIZE;
+		iccom_handle_rx_msg(rx_size);
+		break;
+	case ICCOM_MSG_ACK:
+		iccom_handle_ack_received();
+		break;
+	case ICCOM_MSG_INIT:
+		iccom_set_out_ctrl_reg(ICCOM_HW_CONTROL_INIT);
+		iccom_set_out_msg_reg(0x00000000UL);
+		iccom_initalized = 1;
+		iccom_send_initialization_ack();
+		break;
+	default:
+		// Unexpected message. Do we need to do something here?
+		break;
+	}
+
+	CallTerminateISR2();
+}
+
+ISR(iccomIntClear)
+{
+	iccom_clear_interrupt();
+}
+
+#define APP_Task_iccom_STOP_SEC_CODE
+#include "tpl_memmap.h"
diff --git a/examples/renesas/sample/iccom.h b/examples/renesas/sample/iccom.h
new file mode 100644
index 00000000..5f8b1326
--- /dev/null
+++ b/examples/renesas/sample/iccom.h
@@ -0,0 +1,10 @@
+#ifndef __ICCOM_H__
+#define __ICCOM_H__
+
+#include "iccom_ll.h"
+//#include <Platform_Types.h>
+#include <tpl_os_std_types.h>
+
+void iccom_init(void);
+
+#endif //__ICCOM_H__
diff --git a/examples/renesas/sample/iccom_commands.h b/examples/renesas/sample/iccom_commands.h
new file mode 100644
index 00000000..589692a7
--- /dev/null
+++ b/examples/renesas/sample/iccom_commands.h
@@ -0,0 +1,66 @@
+/*
+ * This header file is shared between Linux and G4 and it includes all the
+ * known iccom commands and replies
+ */
+
+#ifndef __ICCOM_COMMANDS_H__
+#define __ICCOM_COMMANDS_H__
+
+/*
+ * CC-RH has different types compared to Linux, but since this file is shared
+ * it should compile on both systems
+ */
+#ifdef LINUX_TEST_APP
+	#include <stdint.h>
+#else
+	typedef uint8	uint8_t;
+	typedef uint16	uint16_t;
+	typedef uint32	uint32_t;
+	typedef sint32	int32_t;
+#endif
+
+enum iccom_command {
+	NONE = 0,
+	ECHO,
+	OS,
+	BENCH,
+};
+
+#define TOTAL_CTA_SIZE		0x2000
+#define ICCOM_BUF_MAX_SIZE	(TOTAL_CTA_SIZE/2) // Max size of each transaction (read/write)
+
+// this is the common header shared between all commands
+#define CMD_HEADER		\
+		uint8_t cmd_id;
+
+#pragma pack(1)
+struct command_header {
+	CMD_HEADER
+};
+
+#pragma pack(1)
+struct simple_reply_int32 {
+	CMD_HEADER
+	int32_t ret_val;
+};
+#pragma pack(1)
+struct simple_reply_uint32 {
+	CMD_HEADER
+	uint32_t ret_val;
+};
+
+#define MAX_ECHO_DATA_SIZE		((TOTAL_CTA_SIZE/2) - sizeof(uint8_t))
+
+#pragma pack(1)
+struct echo_command {
+	CMD_HEADER
+	uint8_t data[MAX_ECHO_DATA_SIZE];
+};
+
+#pragma pack(1)
+struct echo_reply {
+	CMD_HEADER
+	uint8_t data[MAX_ECHO_DATA_SIZE];
+};
+
+#endif //__ICCOM_COMMANDS_H__
diff --git a/examples/renesas/sample/iccom_ll.c b/examples/renesas/sample/iccom_ll.c
new file mode 100644
index 00000000..64e0229d
--- /dev/null
+++ b/examples/renesas/sample/iccom_ll.c
@@ -0,0 +1,169 @@
+#include "iccom_ll.h"
+#include "iodefine.h"
+#include <string.h>
+//#include "Compiler.h"
+#include "tpl_compiler.h"
+
+uint32 ICCOM_CTA_MEMORY_CH0 = 0x47fc9000;
+uint32 ICCOM_CTA_MEMORY_CH1 = 0x47fca000;
+
+void iccom_ll_init(void)
+{
+	volatile uint32 val = 0;
+
+	/* Enable access to the bus */
+	MCCR_SELB1.STBY_CTRL.UINT32 = 0x00000001;
+	do {
+		val = MCCR_SELB1.STBY_CTRL.UINT32;
+	} while (val != 0x00000001);
+
+	/* Disable MFIS write protection */
+	MFIS0.MFISWPCNTR = 0xACCE0001;
+	do {
+		val = MFIS0.MFISWPCNTR;
+	} while (val != 0x00000001);
+
+	// Enable interrupt EEIC 80 and set its priority to 0
+	INTC2.EIC80.BIT.EIP80 = 0x0;
+	INTC2.EIC80.BIT.EIMK80 = 0x0;
+}
+
+static void iccom_lock(ICCOM_CHANNEL channel)
+{
+	/* nothing at the moment */
+}
+
+static void iccom_unlock(ICCOM_CHANNEL channel)
+{
+	/* nothing at the moment */
+}
+
+/**
+ * Set MFIS CPU communication control register [i] G4MH[k] core to Cortex-A55
+ * CPU core(MFISAM[k]EICR[i])(i=0-7)(k=0-1).
+ *
+ * Support only CPU 0 to G4MH 0
+ */
+void iccom_set_out_ctrl_reg(uint32 val)
+{
+	MFIS0.MFISAM0EICR0 = val;
+}
+
+/**
+ * Get MFIS CPU communication control register [i] G4MH[k] core to Cortex-A55
+ * CPU core(MFISAM[k]EICR[i])(i=0-7)(k=0-1).
+ *
+ * Support only CPU 0 to G4MH 0
+ */
+void iccom_get_out_ctrl_reg(uint32 *pval)
+{
+	volatile uint32 reg = 0;
+	reg = MFIS0.MFISAM0EICR0;
+
+	if (NULL_PTR != pval) {
+		*pval = reg;
+	}
+}
+
+/**
+ * Clear the interruption bit
+ *
+ * MFIS CPU communication control register [i] Cortex-A55 CPU core to G4MH[k]
+ * core(MFISAM[k]IICR[i])(i=0-7)(k=0-1)
+ *
+ * Support only CPU 0 to G4MH 0
+ */
+void iccom_clear_interrupt(void)
+{
+	volatile uint32 reg = 0;
+	reg = MFIS0.MFISAM0IICR0;
+	reg &= ~(ICCOM_CTRL_INT);
+	MFIS0.MFISAM0IICR0 = reg;
+}
+
+/**
+ * Get MFIS CPU communication control register [i] Cortex-A55 CPU core to G4MH[k]
+ * core(MFISAM[k]IICR[i])(i=0-7)(k=0-1)
+ *
+ * Support only CPU 0 to G4MH 0
+ */
+void iccom_get_in_ctrl_reg(uint32 *pval)
+{
+	volatile uint32 reg = 0;
+	reg = MFIS0.MFISAM0IICR0;
+
+	if (NULL_PTR != pval) {
+		*pval = reg;
+	}
+}
+
+void iccom_set_in_ctrl_reg(uint32 val)
+{
+	MFIS0.MFISAM0IICR0 = val;
+}
+
+/**
+ * Set MFIS CPU communication message register [i] G4MH[k] core to Cortex-A55
+ * CPU core(MFISAM[k]EMBR[i])(i=0-7)(k=0-1)
+ *
+ * Support only CPU 0 to G4MH 0
+ */
+void iccom_set_out_msg_reg(uint32 val)
+{
+	MFIS0.MFISAM0EMBR0 = val;
+}
+
+/**
+ * Get MFIS CPU communication message register [i] Cortex-A55 CPU core to
+ * G4MH[k] core(MFISAM[k]IMBR[i])(i=0-7)(k=0-1)
+ *
+ * Support only CPU 0 to G4MH 0
+ */
+void iccom_get_in_msg_reg(uint32 *pval)
+{
+	volatile uint32 reg = 0;
+	reg = MFIS0.MFISAM0IMBR0;
+
+	if (NULL_PTR != pval) {
+		*pval = reg;
+	}
+}
+
+void iccom_clear_interrupt_locked(void)
+{
+	iccom_lock(ICCOM_CHANNEL_0);
+
+	iccom_clear_interrupt();
+
+	iccom_unlock(ICCOM_CHANNEL_0);
+}
+
+void iccom_cta_write(uint8 * buff, size_t size)
+{
+	void* ctaPtr = (void*)ICCOM_CTA_MEMORY_CH1;
+
+	if (buff == NULL_PTR)
+		return;
+
+	memcpy(ctaPtr, buff, size);
+}
+
+void iccom_cta_read(uint8 * buff, size_t size)
+{
+	void* ctaPtr = (void*)ICCOM_CTA_MEMORY_CH0;
+
+	if (buff == NULL)
+		return;
+
+	memcpy(buff, ctaPtr, size);
+}
+
+uint8* iccom_get_read_cta_ptr()
+{
+	return (uint8*)ICCOM_CTA_MEMORY_CH0;
+}
+
+uint8* iccom_cta_write_cta_ptr()
+{
+	return (uint8*)ICCOM_CTA_MEMORY_CH1;
+}
diff --git a/examples/renesas/sample/iccom_ll.h b/examples/renesas/sample/iccom_ll.h
new file mode 100644
index 00000000..c5bfc353
--- /dev/null
+++ b/examples/renesas/sample/iccom_ll.h
@@ -0,0 +1,42 @@
+#ifndef __ICCOM_LL_H__
+#define __ICCOM_LL_H__
+
+//#include <Platform_Types.h>
+#include <tpl_os_std_types.h>
+#include <stddef.h>
+
+static const uint32 ICCOM_HW_CONTROL_INIT = 0x00000000UL;
+
+// IMPORTANT: Keep these masks aligned between CA55 and G4MH
+#define ICCOM_CTRL_INT			(0x00000001U)
+#define ICCOM_CTRL_BUFF_UPPER		(0x00000002U)
+#define ICCOM_CTRL_BUFF_BOTTOM		(0x00000004U)
+#define ICCOM_CTRL_DATA			(0x00000008U)
+#define ICCOM_CTRL_ACK			(0x00000010U)
+#define ICCOM_CTRL_INIT_COMPLETED	(0x00000020U)
+
+typedef enum {
+	ICCOM_CHANNEL_0 = 0,
+} ICCOM_CHANNEL;
+
+/* MFIS HW */
+void iccom_ll_init(void);
+
+void iccom_set_out_ctrl_reg(uint32 val);
+void iccom_get_out_ctrl_reg(uint32 *pval);
+void iccom_set_in_ctrl_reg(uint32 val);
+void iccom_get_in_ctrl_reg(uint32 *pval);
+
+void iccom_set_out_msg_reg(uint32 val);
+void iccom_get_in_msg_reg(uint32 *pval);
+
+void iccom_clear_interrupt(void);
+void iccom_clear_interrupt_locked(void);
+
+void iccom_cta_read(uint8 * buff, size_t size);
+void iccom_cta_write(uint8 * buff, size_t size);
+
+uint8* iccom_get_read_cta_ptr(void);
+uint8* iccom_cta_write_cta_ptr(void);
+
+#endif //__ICCOM_LL_H__
diff --git a/examples/renesas/sample/sample.oil b/examples/renesas/sample/sample.oil
new file mode 100644
index 00000000..b2361511
--- /dev/null
+++ b/examples/renesas/sample/sample.oil
@@ -0,0 +1,72 @@
+OIL_VERSION = "4.2";
+
+IMPLEMENTATION trampoline {
+  TASK {
+    UINT32 STACKSIZE = 2048 ;
+  } ;
+
+  ISR {
+    UINT32 STACKSIZE = 2048 ;
+  } ;
+};
+
+CPU iccom {
+  OS config {
+    STATUS = EXTENDED;
+    PAINT_STACK = TRUE;
+    PAINT_REGISTERS = TRUE;
+    
+    BUILD = TRUE {
+      TRAMPOLINE_BASE_PATH = "../../../";
+      APP_SRC = "iccom.c";
+      APP_SRC = "iccom_ll.c"; 
+      APP_NAME = "sample_exe";
+      APP_SRC = "benchmark.c";
+      APP_SRC = "dhrystone/dhry_1.c";
+      APP_SRC = "dhrystone/dhry_2.c";
+      APP_SRC = "coremark/barebones/core_portme.c";
+      APP_SRC = "coremark/core_list_join.c";
+      APP_SRC = "coremark/core_main.c";
+      APP_SRC = "coremark/core_matrix.c";
+      APP_SRC = "coremark/core_state.c";
+      APP_SRC = "coremark/core_util.c";
+      LDFLAGS="-debug -nocompress -NOOPtimize -memory=high -nologo -SHow=ALL";
+      CFLAGS="-Xcpu=g4mh -g -g_line -Xfxu=off -Xasm_path=.";
+      CFLAGS="-Xfloat=soft -Xdbl_size=8 -Xround=nearest";
+      CFLAGS="-DTIME=TIME";
+      CFLAGS="-Ospeed -Oinline_size";
+      CFLAGS="-I../coremark -I../coremark/barebones -DITERATIONS=30000";
+      LINKER = "rlink";
+      SYSTEM = CMAKE;
+    };
+    SYSTEM_CALL = TRUE;
+  };
+
+  APPMODE std {};
+
+  TASK iccom {
+    PRIORITY = 1;
+    AUTOSTART = FALSE;
+    ACTIVATION = 1;
+    SCHEDULE = FULL;
+  };
+
+  ISR iccomIntClear {
+    CATEGORY = 1;
+    PRIORITY = 1;
+    SOURCE = iccomInt;
+  };
+  
+  ISR iccomInt {
+    CATEGORY = 2; //FSY unsupported
+    PRIORITY = 1;
+    SOURCE = iccomInt; //SysTick;
+  };
+
+  COUNTER SystemCounter {
+    SOURCE = SysTick;
+    MAXALLOWEDVALUE = 10000;
+    TICKSPERBASE = 1;
+    MINCYCLE = 1;
+  };
+};
-- 
2.25.1

