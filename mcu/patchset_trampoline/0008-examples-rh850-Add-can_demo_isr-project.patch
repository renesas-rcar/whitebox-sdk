From 5e28bebcc8ad26b9c3c5e43bce119000a777d51b Mon Sep 17 00:00:00 2001
From: Yuya Hamamachi <yuya.hamamachi.sx@renesas.com>
Date: Mon, 1 Jul 2024 17:45:31 +0900
Subject: [PATCH 4/4] examples: rh850: Add can_demo_isr project

Signed-off-by: Yuya Hamamachi <yuya.hamamachi.sx@renesas.com>
---
 examples/rh850/can_demo_isr/.gitignore       |   4 +
 examples/rh850/can_demo_isr/README.md        |  56 +++++
 examples/rh850/can_demo_isr/build.sh         |  16 ++
 examples/rh850/can_demo_isr/can_demo_isr.c   | 207 +++++++++++++++++++
 examples/rh850/can_demo_isr/can_demo_isr.oil |  71 +++++++
 5 files changed, 354 insertions(+)
 create mode 100644 examples/rh850/can_demo_isr/.gitignore
 create mode 100644 examples/rh850/can_demo_isr/README.md
 create mode 100755 examples/rh850/can_demo_isr/build.sh
 create mode 100644 examples/rh850/can_demo_isr/can_demo_isr.c
 create mode 100644 examples/rh850/can_demo_isr/can_demo_isr.oil

diff --git a/examples/rh850/can_demo_isr/.gitignore b/examples/rh850/can_demo_isr/.gitignore
new file mode 100644
index 00000000..e587f51b
--- /dev/null
+++ b/examples/rh850/can_demo_isr/.gitignore
@@ -0,0 +1,4 @@
+_build/
+build/
+can_demo/
+CMakeLists.txt
diff --git a/examples/rh850/can_demo_isr/README.md b/examples/rh850/can_demo_isr/README.md
new file mode 100644
index 00000000..f47bbf4b
--- /dev/null
+++ b/examples/rh850/can_demo_isr/README.md
@@ -0,0 +1,56 @@
+# Trampoline CAN demo example
+
+This example allows to test the Trampoline CAN stack on the Spider board.
+
+## Hardware setup
+
+Connect a CAN probe to the Spider board CAN0 SUB-D 9 connector (CN13A).
+
+For the test, we used a Kvaser USBcan Pro 2xHS v2 connected to a Windows 10 PC running the Kvaser CanKing software.
+As the Kvaser probe does not provide CAN bus terminating resistors, we made a little adaptation PCB with terminating resistors.
+For that, we cut in half two DB-9 cables and kept the two female parts.
+On the PCB, we wired the DB-9 pins 7 together (the CAN high signal), the DB-9 pins 2 together (the CAN low signal) and the DB-9 pins 3 together (the CAN ground).
+Between the DB-9 pin 7 and pin 3 we soldered a 60 ohms resistors, we also added a second 60 ohms resistors between the DB-9 pin 2 and pin 3.
+
+## Software setup
+
+The Kvaser CanKing CAN bus configuration is as follow :
+* CAN Mode : CAN FD
+* Both Arbitration Phase and Data Phase parameters set to :
+  * Bus speed : 1000 Kbit/s, 80%.
+  * SJW : 8
+  * Bit timing : Tseg1=31, Tseg2=8.
+
+No configuration is needed on the CAN demo application side.
+
+## Building
+
+### Prerequisites
+
+A PC running Windows 10 or above is needed.
+* First, install the free version of the [RH850 Compiler CC-RH for CS+](https://www.renesas.com/us/en/document/ucm/rh850-compiler-cc-rh-v20500-cs?r=1169506) to the default location. The version 2.05.00 was used at the time of writing.
+* Install [Cygwin](https://www.cygwin.com/setup-x86_64.exe). Select the `cmake` and `make` packages during installation. The CMake version used at the time of writing is 3.24.2.
+
+### Building
+
+Open a Cygwin terminal and go to the Trampoline directory.
+Then, run the following commands :
+
+```
+# Tell the build system where the compiler is located
+export HLNK_DIR='C:\Program Files (x86)\Renesas Electronics\CS+\CC\CC-RH\V2.05.00'
+
+cd examples/rh850/can_demo
+./build.sh
+```
+
+If you want to generate a `.srec` file to directly flash on the board, look at the `memory_unlocker` example `build.sh` script in the same directory than the `can_demo`.
+
+## Running
+
+Before starting the CAN demo application, connect the hardware setup and configure the Kvaser CanKing application as described in the above paragraphs.
+Then, click the CanKing `Go On Bus` button.
+Now, you can run the CAN demo application.
+
+The CAN demo application starts by sending a CAN frame with the CAN ID `0x123` and the string payload `Ready!`.
+After that, it waits for a CAN frame to be received. When a frame is received, it increments the CAN ID and all the payload bytes, then it sends the frame back.
diff --git a/examples/rh850/can_demo_isr/build.sh b/examples/rh850/can_demo_isr/build.sh
new file mode 100755
index 00000000..b8141928
--- /dev/null
+++ b/examples/rh850/can_demo_isr/build.sh
@@ -0,0 +1,16 @@
+#!/usr/bin/env bash
+
+set -e
+
+PROGRAM_NAME=can_demo_isr
+
+echo "*** Run Goil ***"
+mkdir -p _build
+goil --target=rh850/g4mh --templates=../../../goil/templates/ ${PROGRAM_NAME}.oil
+
+echo "*** Run CMake ***"
+cd _build
+cmake -G "Unix Makefiles" -D CMAKE_TOOLCHAIN_FILE=../${PROGRAM_NAME}/compiler.cmake ..
+
+echo "*** Run Make ***"
+make
diff --git a/examples/rh850/can_demo_isr/can_demo_isr.c b/examples/rh850/can_demo_isr/can_demo_isr.c
new file mode 100644
index 00000000..88bf4fbb
--- /dev/null
+++ b/examples/rh850/can_demo_isr/can_demo_isr.c
@@ -0,0 +1,207 @@
+/**
+ * @file can_demo.c
+ *
+ * @section desc File description
+ *
+ * Echo the received CAN frames after incrementing the CAN ID and the payload
+ * bytes.
+ *
+ * @section copyright Copyright
+ *
+ * Trampoline OS
+ *
+ * Trampoline is copyright (c) IRCCyN 2005+
+ * Trampoline is protected by the French intellectual property law.
+ *
+ * (C) BayLibre 2023
+ *
+ * This software is distributed under the Lesser GNU Public Licence
+ *
+ *  @section infos File informations
+ *
+ *  $Date$
+ *  $Rev$
+ *  $Author$
+ *  $URL$
+ */
+#include <Can.h>
+#include <CanIf.h>
+#include <spider_can.h>
+#include <stdio.h>
+#include <string.h>
+#include <tpl_os.h>
+
+#include "spider_serial.h"
+#include "printf.h"
+
+#define CPUCLK_MHZ 400UL
+#define WAIT_US(t) \
+    { \
+        volatile uint32 cnt; \
+        for (cnt = 0; \
+             cnt < (((uint32)CPUCLK_MHZ * ((uint32)t)) + (uint32)1); \
+             cnt++); \
+    }
+
+// Statically list the configuration of each CAN controller used in the application
+static tpl_can_controller_config_t can_controllers_config[] =
+{
+	// First controller will use CAN 2.0
+	{
+		&spider_can_controller_0,
+		// CAN-FD at 1Mbps without BRS
+		#if 1
+		{
+			1000, // CanControllerBaudRate
+			0, // CanControllerBaudRateConfigID
+			1, // CanControllerPropSeg, fine tune the bus speed, it is measured at 1MHz
+			5, // CanControllerSeg1
+			2, // CanControllerSeg2
+			2, // CanControllerSyncJumpWidth
+			TRUE, // use_fd_configuration
+			{
+				5000, // CanControllerFdBaudRate, still clocked at 1Mbps
+				2, // CanControllerPropSeg
+				10, // CanControllerSeg1
+				5, // CanControllerSeg2
+				15, // CanControllerSspOffset
+				5, // CanControllerSyncJumpWidth
+				FALSE // CanControllerTxBitRateSwitch
+			}
+		}
+		#endif
+	}
+};
+
+int main(void)
+{
+	static Can_ConfigType can_config_type =
+	{
+		can_controllers_config,
+		sizeof(can_controllers_config) / sizeof(can_controllers_config[0])
+	};
+	int ret, i;
+	// CAN definition
+	Can_PduType can_pdu;
+	PduInfoType pdu_info;
+	uint8 payload[TPL_CAN_FD_FRAME_MAXIMUM_PAYLOAD_SIZE];
+
+	// Serial Init
+	WAIT_US(44*1000); // This is for debug. delay serial log to show it near U-boot log. 
+
+	Serial_Init();
+	debug_printf("[G4MH] Serial: driver is initialized\r\n");
+
+	// Initialize the CAN module 0 channel 0 with the enabled configuration
+	for (i = 0; i < 3; ++i)
+		ret = Can_Init(&can_config_type);
+	if (ret)
+		return -1;
+	debug_printf("[G4MH] CAN: driver is initialized\r\n");
+
+	// Send a frame to tell that the program is ready
+	can_pdu.id = 0x123 | TPL_CAN_ID_TYPE_STANDARD;
+	can_pdu.sdu = payload;
+	strcpy((char *) can_pdu.sdu, "Ready!");
+	can_pdu.length = strlen((char *) can_pdu.sdu);
+	pdu_info.SduDataPtr = (uint8 *) &can_pdu;
+	pdu_info.SduLength = sizeof(can_pdu) + can_pdu.length;
+	CanIf_Transmit(0, &pdu_info);
+
+	StartOS(OSDEFAULTAPPMODE);
+	return 0;
+}
+
+void can_recv_proc() {
+	// CAN definition
+	static Can_PduType can_pdu, *pointer_can_pdu;
+	static PduInfoType pdu_info;
+	static int i;
+	static Can_IdType id_without_flags, id_flags;
+	static uint8 payload[TPL_CAN_FD_FRAME_MAXIMUM_PAYLOAD_SIZE];
+
+	strcpy((char *) can_pdu.sdu, "Ready!");
+	can_pdu.sdu = payload;
+	can_pdu.length = strlen((char *) can_pdu.sdu);
+	pdu_info.SduDataPtr = (uint8 *) &can_pdu;
+	pdu_info.SduLength = sizeof(can_pdu) + can_pdu.length;
+
+	//debug_printf("[G4MH] RSCAN0 interrupt is detected\r\n");
+
+	// Wait for a frame, then increment its ID and payload and send it back
+	while (CanIf_ReadRxPduData(0, &pdu_info) != E_OK);
+
+	{
+		// Make sure the payload size is compatible with CAN-FD
+		pointer_can_pdu = (Can_PduType *) pdu_info.SduDataPtr;
+
+		// Show the received frame via Serial 
+		/*
+		debug_printf("[G4MH] CAN frame: id=%03x: ", pointer_can_pdu->id );
+		for (i=0; i<pointer_can_pdu->length; i++){
+			debug_printf("%02x ", pointer_can_pdu->sdu[i]);
+		}
+		debug_printf("\r\n");
+		*/
+
+		if (pointer_can_pdu->length > TPL_CAN_FD_FRAME_MAXIMUM_PAYLOAD_SIZE)
+			return;
+
+		// Increment the CAN ID and wrap to 0 if the highest ID was received
+		id_flags = pointer_can_pdu->id & TPL_CAN_ID_TYPE_MASK;
+		if ((id_flags == TPL_CAN_ID_TYPE_STANDARD) || (id_flags == TPL_CAN_ID_TYPE_FD_STANDARD))
+		{
+			id_without_flags = pointer_can_pdu->id & TPL_CAN_ID_STANDARD_MASK;
+			if (id_without_flags >= 1023) // 11-bit standard ID
+				id_without_flags = 0;
+			else
+				id_without_flags++;
+		}
+		else
+		{
+			id_without_flags = pointer_can_pdu->id & TPL_CAN_ID_EXTENDED_MASK;
+			if (id_without_flags >= 536870911) // 29-bit extended ID
+				id_without_flags = 0;
+			else
+				id_without_flags++;
+		}
+		pointer_can_pdu->id = id_flags | id_without_flags;
+
+		// Increment the payload bytes
+		for (i = 0; i < pointer_can_pdu->length; i++)
+			pointer_can_pdu->sdu[i]++;
+
+		// Send the incremented frame back
+		// debug_printf("[G4MH] Transmit the frame\r\n");
+		CanIf_Transmit(0, &pdu_info);
+	}
+}
+
+/* ISR function for RX*/
+ISR(RSCAN0_RX_Int)
+{
+	can_recv_proc();
+	CallTerminateISR2();
+}
+
+ISR(RSCAN0_RX_IntClear)
+{
+	// debug_printf("[G4MH] RSCAN0_RX_Int is cleared\r\n");
+	spider_can_clear_rx_interrupt(can_controllers_config);
+}
+
+/* ISR function for TX ch0*/
+ISR(RSCAN0_TX_CH0_Int)
+{
+	static uint32 can_frame = 0;
+	debug_printf("[G4MH] CAN frame is transmitted(total = %u)\r\n", ++can_frame);
+	CallTerminateISR2();
+}
+
+ISR(RSCAN0_TX_CH0_IntClear)
+{
+	// debug_printf("[G4MH] RSCAN0_TX_CH0_Int is cleared\r\n");
+	spider_can_clear_tx_ch0_interrupt(can_controllers_config);
+}
+
+TASK(can_task){} // Dummy function
diff --git a/examples/rh850/can_demo_isr/can_demo_isr.oil b/examples/rh850/can_demo_isr/can_demo_isr.oil
new file mode 100644
index 00000000..ed5ec2ab
--- /dev/null
+++ b/examples/rh850/can_demo_isr/can_demo_isr.oil
@@ -0,0 +1,71 @@
+OIL_VERSION = "4.0";
+
+IMPLEMENTATION trampoline {
+	/* This fix the default STACKSIZE of tasks */
+	TASK {
+		UINT32 STACKSIZE = 2048 ;
+	};
+
+	/* This fix the default STACKSIZE of ISRs */
+	ISR {
+		UINT32 STACKSIZE = 2048 ;
+	};
+};
+
+CPU can_task {
+	OS config {
+		STATUS = EXTENDED;
+		PAINT_STACK = TRUE;
+		PAINT_REGISTERS = TRUE;
+		BUILD = TRUE {
+			TRAMPOLINE_BASE_PATH = "../../../";
+			APP_SRC = "can_demo_isr.c";
+			APP_NAME = "can_demo_isr_exe";
+			LDFLAGS="-debug -nocompress -NOOPtimize -memory=high -nologo -SHow=ALL";
+			CFLAGS="-Xcpu=g4mh -g -g_line -Xfxu=off -Xasm_path=.";
+			LINKER = "rlink";
+			SYSTEM = CMAKE;
+			LIBRARY = can;
+
+			LIBRARY = serial;
+			CFLAGS="-DHSCIF_921600BPS";
+		};
+		SYSTEM_CALL = TRUE;
+	};
+
+	APPMODE stdAppmode {};
+
+	TASK can_task {
+		PRIORITY = 1;
+		AUTOSTART = TRUE {
+			APPMODE = stdAppmode;
+		};
+		ACTIVATION = 1;
+		SCHEDULE = FULL;
+	};
+
+	ISR RSCAN0_RX_IntClear {
+		CATEGORY = 1;
+		PRIORITY = 1;
+		SOURCE = RSCAN0_RX_Int;
+	};
+
+	ISR RSCAN0_RX_Int {
+		CATEGORY = 2; //FSY unsupported
+		PRIORITY = 1;
+		SOURCE = RSCAN0_RX_Int;
+	};
+
+	ISR RSCAN0_TX_CH0_IntClear {
+		CATEGORY = 1;
+		PRIORITY = 1;
+		SOURCE = RSCAN0_TX_CH0_Int;
+	};
+
+	ISR RSCAN0_TX_CH0_Int {
+		CATEGORY = 2; //FSY unsupported
+		PRIORITY = 1;
+		SOURCE = RSCAN0_TX_CH0_Int;
+	};
+
+};
-- 
2.34.1

