From 062b9b6eb88287415421e1a0e28051cb45b3ce84 Mon Sep 17 00:00:00 2001
From: Florian Sylvestre <fsylvestre@baylibre.com>
Date: Mon, 23 Oct 2023 14:33:53 +0200
Subject: [PATCH 01/38] spider: add COM support by using SCIF/HSCIF

---
 goil/templates/config/renesas/config.oil |  10 ++
 machines/renesas/drivers/serial/printf.c | 188 +++++++++++++++++++++++
 machines/renesas/drivers/serial/printf.h |   7 +
 machines/renesas/drivers/serial/serial.c |  98 ++++++++++++
 machines/renesas/drivers/serial/serial.h | 104 +++++++++++++
 5 files changed, 407 insertions(+)
 create mode 100644 machines/renesas/drivers/serial/printf.c
 create mode 100644 machines/renesas/drivers/serial/printf.h
 create mode 100644 machines/renesas/drivers/serial/serial.c
 create mode 100644 machines/renesas/drivers/serial/serial.h

diff --git a/goil/templates/config/renesas/config.oil b/goil/templates/config/renesas/config.oil
index de3b27df..83da8a9f 100755
--- a/goil/templates/config/renesas/config.oil
+++ b/goil/templates/config/renesas/config.oil
@@ -23,6 +23,10 @@ IMPLEMENTATION renesas {
   OS {
     BOOLEAN [
       TRUE {
+        ENUM [
+          serial
+        ] LIBRARY[];
+
         STRING APP_SRC[];
         STRING CFLAGS[];
         STRING CPPFLAGS[];
@@ -56,6 +60,12 @@ CPU renesas {
     CFILE  = "renesas_irq.c";
   };
 
+  LIBRARY serial {
+    PATH = "renesas/drivers/serial";
+    CFILE = "serial.c";
+    CFILE = "printf.c";
+  };
+
   INTERRUPT_COUNT nb_it {
     IT_TABLE_SIZE = 767;
   };
diff --git a/machines/renesas/drivers/serial/printf.c b/machines/renesas/drivers/serial/printf.c
new file mode 100644
index 00000000..a53e9a86
--- /dev/null
+++ b/machines/renesas/drivers/serial/printf.c
@@ -0,0 +1,188 @@
+/*
+    Copyright 2001-2021 Georges Menie
+    https://www.menie.org/georges/embedded/small_printf_source_code.html
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "printf.h"
+#include "serial.h"
+
+static void printchar(char **str, int c)
+{
+    if (str) {
+        **str = c;
+        ++(*str);
+    } else {
+        Serial_Tx(c);
+    }
+}
+
+#define PAD_RIGHT 1
+#define PAD_ZERO 2
+
+static int prints(char **out, const char *string, int width, int pad)
+{
+	register int pc = 0, padchar = ' ';
+
+	if (width > 0) {
+		register int len = 0;
+		register const char *ptr;
+		for (ptr = string; *ptr; ++ptr) ++len;
+		if (len >= width) width = 0;
+		else width -= len;
+		if (pad & PAD_ZERO) padchar = '0';
+	}
+	if (!(pad & PAD_RIGHT)) {
+		for ( ; width > 0; --width) {
+			printchar (out, padchar);
+			++pc;
+		}
+	}
+	for ( ; *string ; ++string) {
+		printchar (out, *string);
+		++pc;
+	}
+	for ( ; width > 0; --width) {
+		printchar (out, padchar);
+		++pc;
+	}
+
+	return pc;
+}
+
+/* the following should be enough for 32 bit int */
+#define PRINT_BUF_LEN 12
+
+static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
+{
+	char print_buf[PRINT_BUF_LEN];
+	register char *s;
+	register int t, neg = 0, pc = 0;
+	register unsigned int u = i;
+
+	if (i == 0) {
+		print_buf[0] = '0';
+		print_buf[1] = '\0';
+		return prints (out, print_buf, width, pad);
+	}
+
+	if (sg && b == 10 && i < 0) {
+		neg = 1;
+		u = -i;
+	}
+
+	s = print_buf + PRINT_BUF_LEN-1;
+	*s = '\0';
+
+	while (u) {
+		t = u % b;
+		if( t >= 10 )
+			t += letbase - '0' - 10;
+		*--s = t + '0';
+		u /= b;
+	}
+
+	if (neg) {
+		if( width && (pad & PAD_ZERO) ) {
+			printchar (out, '-');
+			++pc;
+			--width;
+		}
+		else {
+			*--s = '-';
+		}
+	}
+
+	return pc + prints (out, s, width, pad);
+}
+
+static int print(char **out, int *varg)
+{
+	register int width, pad;
+	register int pc = 0;
+	register char *format = (char *)(*varg++);
+	char scr[2];
+
+	for (; *format != 0; ++format) {
+		if (*format == '%') {
+			++format;
+			width = pad = 0;
+			if (*format == '\0') break;
+			if (*format == '%') goto out;
+			if (*format == '-') {
+				++format;
+				pad = PAD_RIGHT;
+			}
+			while (*format == '0') {
+				++format;
+				pad |= PAD_ZERO;
+			}
+			for ( ; *format >= '0' && *format <= '9'; ++format) {
+				width *= 10;
+				width += *format - '0';
+			}
+			if( *format == 's' ) {
+				register char *s = *((char **)varg++);
+				pc += prints (out, s?s:"(null)", width, pad);
+				continue;
+			}
+			if( *format == 'd' ) {
+				pc += printi (out, *varg++, 10, 1, width, pad, 'a');
+				continue;
+			}
+			if( *format == 'x' ) {
+				pc += printi (out, *varg++, 16, 0, width, pad, 'a');
+				continue;
+			}
+			if( *format == 'X' ) {
+				pc += printi (out, *varg++, 16, 0, width, pad, 'A');
+				continue;
+			}
+			if( *format == 'u' ) {
+				pc += printi (out, *varg++, 10, 0, width, pad, 'a');
+				continue;
+			}
+			if( *format == 'c' ) {
+				/* char are converted to int then pushed on the stack */
+				scr[0] = *varg++;
+				scr[1] = '\0';
+				pc += prints (out, scr, width, pad);
+				continue;
+			}
+		}
+		else {
+		out:
+			printchar (out, *format);
+			++pc;
+		}
+	}
+	if (out) **out = '\0';
+	return pc;
+}
+
+/* assuming sizeof(void *) == sizeof(int) */
+
+int debug_printf(const char *format, ...)
+{
+	register int *varg = (int *)(&format);
+	return print(0, varg);
+}
+
+int debug_sprintf(char *out, const char *format, ...)
+{
+	register int *varg = (int *)(&format);
+	return print(&out, varg);
+}
\ No newline at end of file
diff --git a/machines/renesas/drivers/serial/printf.h b/machines/renesas/drivers/serial/printf.h
new file mode 100644
index 00000000..aea99a83
--- /dev/null
+++ b/machines/renesas/drivers/serial/printf.h
@@ -0,0 +1,7 @@
+#ifndef __PRINTF_H__
+#define __PRINTF_H__
+
+int debug_printf(const char *format, ...);
+int debug_sprintf(char *out, const char *format, ...);
+
+#endif
diff --git a/machines/renesas/drivers/serial/serial.c b/machines/renesas/drivers/serial/serial.c
new file mode 100644
index 00000000..e93a7efb
--- /dev/null
+++ b/machines/renesas/drivers/serial/serial.c
@@ -0,0 +1,98 @@
+#include "serial.h"
+#include "iodefine.h"
+
+uint32 Serial_Init(void)
+{
+  volatile uint8  wait_cmpt;
+	volatile uint32 val = 0;
+
+	/* Enable access to the bus */
+	MCCR_SELB1.STBY_CTRL.UINT32 = 0x00000001;
+	do {
+		val = MCCR_SELB1.STBY_CTRL.UINT32;
+	} while (val != 0x00000001);
+
+  /* Clear bits TE and RE in HSSCR to 0 */
+  SERIAL_SCR =  SERIAL_SCR_INT_VALUE;
+
+  /* Set bits TFRST and RFRST in FCR to 1 */
+  SERIAL_FCR |= SERIAL_FCR_TFRST_MASK | SERIAL_FCR_RFRS_MASK;
+
+  /* Clear flags ER, DR, BRK, and RDF in FSR */
+  SERIAL_FSR =  SERIAL_FSR_INIT_VALUE;
+
+  /* Clear TO and ORER in LSR,*/
+  SERIAL_LSR =  SERIAL_LSR_INIT_VALUE;
+
+  /* Set bits CKE[1:0] in SCR (leaving other bits cleared to 0) */
+  SERIAL_SCR   =  (SERIAL_SCR & ~SERIAL_SCR_CKE_MASK) | SERIAL_SCR_CKE_INIT_VALUE;
+
+  /* Set data transfer format in HSSMR ( 8 bits, no parity, 1 stop bit, async) */
+  SERIAL_SMR = SERIAL_SMR_INIT_VALUE;
+
+  /* Baud rate setting */
+  SERIAL_BRR = SERIAL_BAUDRATE;
+                      
+#if (SERIAL_BASE_ADDR == SCIF_BASE_ADDR)
+  /* SCIF module used */
+  SERIAL_DL    = SERIAL_DL_SETTING_VALUE;
+  SERIAL_CKS   &= ~(SERIAL_CKS_DIV_MASK | SERIAL_CKS_XIN_MASK);
+#else
+  /* HSCIF module used */
+  /* Sampling rate 8  */
+  SERIAL_SRR = SERIAL_SRR_VAL;
+#endif
+
+  for (wait_cmpt = 0; wait_cmpt < 100; wait_cmpt++)
+  {
+  }
+
+  /* reset-off, tx-fifo, rx-fifo */
+  SERIAL_FCR = SERIAL_FCR_INIT_VALUE;
+
+  /* Enable TE and RE bits*/
+  SERIAL_SCR |= SERIAL_SCR_TE_MASK | SERIAL_SCR_RE_MASK;
+
+  return 1;
+}
+
+void Serial_Tx_Wait(void)
+{
+  /* Wait until TX FIFO is empty */
+  do
+  {
+  } while ((SERIAL_FSR & SERIAL_TX_DONE) != SERIAL_TX_DONE);
+}
+
+uint32 Serial_Tx(uint8 data)
+{
+  Serial_Tx_Wait();
+
+  /* Fill FTDR register with data to send */
+  SERIAL_FTDR = data;
+
+  /* Clear TX status bits */
+  SERIAL_FSR &= ~SERIAL_TX_DONE;
+
+  return 1;
+}
+
+uint8 Serial_Rx(uint8* data)
+{
+  /* Check if data available */
+  if((SERIAL_FSR & SERIAL_FSR_RDF_MASK) != SERIAL_FSR_RDF_MASK)
+    return 0;
+
+  /* Check Data Ready and no break, timeout, overrun nor receive errors */
+  if (((SERIAL_FSR & SERIAL_RX_READY) != 0) || (SERIAL_LSR != 0))
+    return 2;
+
+  /* Get rx data */
+  *data = SERIAL_FRDR;
+  /* Send back data */
+  Serial_Tx(*data);
+  /* Clear RDF flag */
+  SERIAL_FSR &= ~SERIAL_FSR_RDF_MASK;
+
+  return 1;
+}
diff --git a/machines/renesas/drivers/serial/serial.h b/machines/renesas/drivers/serial/serial.h
new file mode 100644
index 00000000..7806f196
--- /dev/null
+++ b/machines/renesas/drivers/serial/serial.h
@@ -0,0 +1,104 @@
+#ifndef SERIAL_H
+#define SERIAL_H
+
+#include "tpl_os.h"
+
+
+// /* Calculate the base address of each register after remapping */
+// #define	ICU_REMAP0		(0xFC000000U)
+// #define	ICU_REMAP_CALC(val)	(ICU_REMAP0 + ((uint32)(val) * 0x00200000U))
+// #define	ICU_REMAP_NUM_HSCIF		(7U)	/* HSCIF */
+// #define	ICU_REMAP_NUM_SCIF		(9U)	/* SCIF */
+// #define	ICU_REMAP_OFFSET_SCIF3		(0x00050000U)
+// #define	ICU_REMAP_OFFSET_HSCIF0		(0x00140000U)
+
+/* SCIF3 */
+#define SCIF_BASE_ADDR                      0xD6C50000
+
+/* HSCIF0 */
+#define HSCIF_BASE_ADDR                     0xD6540000
+
+/* BRR computing:
+ *   HSBRR: Register value = Internal clock / ( Sr * 2^(2*n + 1) * B) * 10^6 -1
+ *   SCBRR: Register value = PCK / ( 64 * 2^(2*n - 1) * B) * 10^6 -1
+ *
+ *   with:
+ *     - PCK: Peripheral module operating frequency (MHz)
+ *     - B: Baudrate
+ *     - Sr: Sampling rate (8 to 32)
+ *     - n: Baudrate generator clock (0 to 3)
+ *
+ *   In our case:  Internal clock = 266, Sr = 8, PCK = 66 and n = 0
+ */
+#define HSBRR_1843200BPS              (uint8)(0x08U)
+#define HSBRR_921600BPS               (uint8)(0x11U)
+#define SCBRR_115200BPS               (uint8)(0x11U)
+
+/* A proper #define must be used between: SCIF_115200BPS, HSCIF_921600BPS and HSCIF_1843200BPS */
+#if defined SCIF_115200BPS
+#define SERIAL_BASE_ADDR                     SCIF_BASE_ADDR
+#define SERIAL_BAUDRATE                      SCBRR_115200BPS
+#elif defined HSCIF_921600BPS
+#define SERIAL_BASE_ADDR                     HSCIF_BASE_ADDR
+#define SERIAL_BAUDRATE                      HSBRR_921600BPS
+#elif defined HSCIF_1843200BPS
+#define SERIAL_BASE_ADDR                     HSCIF_BASE_ADDR
+#define SERIAL_BAUDRATE                      HSBRR_1843200BPS
+#else
+#error "No baudrate defined for serial communication"
+#endif
+
+#define SERIAL_SMR        (*(volatile uint16 *)(SERIAL_BASE_ADDR + 0x00))
+#define SERIAL_BRR        (*(volatile uint8  *)(SERIAL_BASE_ADDR + 0x04))
+#define SERIAL_SCR        (*(volatile uint16 *)(SERIAL_BASE_ADDR + 0x08))
+#define SERIAL_FTDR       (*(volatile uint8  *)(SERIAL_BASE_ADDR + 0x0C))
+#define SERIAL_FSR        (*(volatile uint16 *)(SERIAL_BASE_ADDR + 0x10))
+#define SERIAL_FRDR       (*(volatile uint8  *)(SERIAL_BASE_ADDR + 0x14))
+#define SERIAL_FCR        (*(volatile uint16 *)(SERIAL_BASE_ADDR + 0x18))
+#define SERIAL_FDR        (*(volatile uint16 *)(SERIAL_BASE_ADDR + 0x1C))
+#define SERIAL_SPTR       (*(volatile uint16 *)(SERIAL_BASE_ADDR + 0x20))
+#define SERIAL_LSR        (*(volatile uint16 *)(SERIAL_BASE_ADDR + 0x24))
+#define SERIAL_DL         (*(volatile uint16 *)(SERIAL_BASE_ADDR + 0x30)) /* Only used by SCIF */
+#define SERIAL_CKS        (*(volatile uint16 *)(SERIAL_BASE_ADDR + 0x34)) /* Only used by SCIF */
+#define SERIAL_SRR        (*(volatile uint16 *)(SERIAL_BASE_ADDR + 0x40)) /* Only used by HSCIF */
+
+#define SERIAL_SMR_INIT_VALUE       (0x0000U)
+
+#define SERIAL_SCR_INT_VALUE        (0x0000U)
+#define SERIAL_SCR_CKE_MASK         (3U << 0)
+#define SERIAL_SCR_CKE_BRG_VALUE    (0x0002U)
+#define SERIAL_SCR_CKE_INIT_VALUE   (0x0000U)
+#define SERIAL_SCR_RE_MASK          (1U << 4)
+#define SERIAL_SCR_TE_MASK          (1U << 5)
+
+#define SERIAL_FSR_INIT_VALUE       (0x0000U)
+#define SERIAL_FSR_DR_MASK          (1U << 0)
+#define SERIAL_FSR_RDF_MASK         (1U << 1)
+#define SERIAL_FSR_BRK_MASK         (1U << 4)
+#define SERIAL_FSR_TDFE_MASK        (1U << 5)
+#define SERIAL_FSR_TEND_MASK        (1U << 6)
+#define SERIAL_FSR_ER_MASK          (1U << 7)
+#define SERIAL_RX_READY             (SERIAL_FSR_DR_MASK | SERIAL_FSR_BRK_MASK | SERIAL_FSR_ER_MASK)
+#define SERIAL_TX_DONE              (SERIAL_FSR_TDFE_MASK | SERIAL_FSR_TEND_MASK)
+
+#define SERIAL_FCR_INIT_VALUE       (0x0000U)
+#define SERIAL_FCR_TFRST_MASK       (1U << 2)
+#define SERIAL_FCR_RFRS_MASK        (1U << 1)
+
+#define SERIAL_LSR_INIT_VALUE       (0x0000U)
+
+#define SERIAL_DL_SETTING_VALUE     (0x0008U)
+
+#define SERIAL_CKS_DIV_MASK         (1U << 15)
+#define SERIAL_CKS_XIN_MASK         (1U << 14)
+
+#define SERIAL_SRR_SRE              (1U << 15)
+#define SERIAL_SRR_SRCYC8           (7U << 0)
+#define SERIAL_SRR_VAL              (SERIAL_SRR_SRE | SERIAL_SRR_SRCYC8)
+
+uint32 Serial_Init(void);
+void Serial_Tx_Wait(void);
+uint32 Serial_Tx(uint8 data);
+uint8  Serial_Rx(uint8* data);
+
+#endif
-- 
2.34.1

