From 1c5e56dc0d282c26c53966eb937cf378f332e5b9 Mon Sep 17 00:00:00 2001
From: Tsutomu Muroya <tsutomu.muroya.jy@bp.renesas.com>
Date: Thu, 2 Nov 2023 17:03:03 +0900
Subject: [PATCH] trampoline: Add can for sample project

Signed-off-by: Tsutomu Muroya <tsutomu.muroya.jy@bp.renesas.com>
---
 examples/renesas/sample/can_demo.c | 147 +++++++++++++++++++++++++++++
 examples/renesas/sample/sample.c   |   2 +
 examples/renesas/sample/sample.oil |  12 +++
 3 files changed, 161 insertions(+)
 create mode 100644 examples/renesas/sample/can_demo.c

diff --git a/examples/renesas/sample/can_demo.c b/examples/renesas/sample/can_demo.c
new file mode 100644
index 00000000..fd2d6680
--- /dev/null
+++ b/examples/renesas/sample/can_demo.c
@@ -0,0 +1,147 @@
+/**
+ * @file can_demo.c
+ *
+ * @section desc File description
+ *
+ * Echo the received CAN frames after incrementing the CAN ID and the payload
+ * bytes.
+ *
+ * @section copyright Copyright
+ *
+ * Trampoline OS
+ *
+ * Trampoline is copyright (c) IRCCyN 2005+
+ * Trampoline is protected by the French intellectual property law.
+ *
+ * (C) BayLibre 2023
+ *
+ * This software is distributed under the Lesser GNU Public Licence
+ *
+ *  @section infos File informations
+ *
+ *  $Date$
+ *  $Rev$
+ *  $Author$
+ *  $URL$
+ */
+#include <Can.h>
+#include <CanIf.h>
+#include <spider_can.h>
+#include <stdio.h>
+#include <string.h>
+#include <tpl_os.h>
+
+int can_demo_init(void)
+{
+	// Statically list the configuration of each CAN controller used in the application
+	static tpl_can_controller_config_t can_controllers_config[] =
+	{
+		// First controller will use CAN 2.0
+		{
+			&spider_can_controller_0,
+			// CAN 2.0 at 250Kbps
+			#if 0
+			{
+				250, // CanControllerBaudRate
+				0, // CanControllerBaudRateConfigID
+				1, // CanControllerPropSeg, fine tune the bus speed, it is measured at 245KHz
+				11, // CanControllerSeg1
+				4, // CanControllerSeg2
+				4, // CanControllerSyncJumpWidth
+				FALSE // use_fd_configuration
+			}
+			#endif
+			// CAN-FD at 1Mbps without BRS
+			#if 1
+			{
+				1000, // CanControllerBaudRate
+				0, // CanControllerBaudRateConfigID
+				1, // CanControllerPropSeg, fine tune the bus speed, it is measured at 1MHz
+				5, // CanControllerSeg1
+				2, // CanControllerSeg2
+				2, // CanControllerSyncJumpWidth
+				TRUE, // use_fd_configuration
+				{
+					5000, // CanControllerFdBaudRate, still clocked at 1Mbps
+					2, // CanControllerPropSeg
+					10, // CanControllerSeg1
+					5, // CanControllerSeg2
+					15, // CanControllerSspOffset
+					5, // CanControllerSyncJumpWidth
+					FALSE // CanControllerTxBitRateSwitch
+				}
+			}
+			#endif
+		}
+	};
+	static Can_ConfigType can_config_type =
+	{
+		can_controllers_config,
+		sizeof(can_controllers_config) / sizeof(can_controllers_config[0])
+	};
+	int ret;
+
+	// Initialize the CAN module 0 channel 0 with the enabled configuration
+	ret = Can_Init(&can_config_type);
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+TASK(can_task)
+{
+	Can_PduType can_pdu, *pointer_can_pdu;
+	PduInfoType pdu_info;
+	uint8 payload[TPL_CAN_FD_FRAME_MAXIMUM_PAYLOAD_SIZE];
+	int i;
+	Can_IdType id_without_flags, id_flags;
+
+	// Send a frame to tell that the program is ready
+	can_pdu.id = 0x123 | TPL_CAN_ID_TYPE_STANDARD;
+	can_pdu.sdu = payload;
+	strcpy((char *) can_pdu.sdu, "Ready!");
+	can_pdu.length = strlen((char *) can_pdu.sdu);
+	pdu_info.SduDataPtr = (uint8 *) &can_pdu;
+	pdu_info.SduLength = sizeof(can_pdu) + can_pdu.length;
+	CanIf_Transmit(0, &pdu_info);
+
+	// Wait for a frame, then increment its ID and payload and send it back
+	while (1)
+	{
+		if (CanIf_ReadRxPduData(0, &pdu_info) == E_OK)
+		{
+			// Make sure the payload size is compatible with CAN-FD
+			pointer_can_pdu = (Can_PduType *) pdu_info.SduDataPtr;
+			if (pointer_can_pdu->length > TPL_CAN_FD_FRAME_MAXIMUM_PAYLOAD_SIZE)
+				continue;
+
+			// Increment the CAN ID and wrap to 0 if the highest ID was received
+			id_flags = pointer_can_pdu->id & TPL_CAN_ID_TYPE_MASK;
+			if ((id_flags == TPL_CAN_ID_TYPE_STANDARD) || (id_flags == TPL_CAN_ID_TYPE_FD_STANDARD))
+			{
+				id_without_flags = pointer_can_pdu->id & TPL_CAN_ID_STANDARD_MASK;
+				if (id_without_flags >= 1023) // 11-bit standard ID
+					id_without_flags = 0;
+				else
+					id_without_flags++;
+			}
+			else
+			{
+				id_without_flags = pointer_can_pdu->id & TPL_CAN_ID_EXTENDED_MASK;
+				if (id_without_flags >= 536870911) // 29-bit extended ID
+					id_without_flags = 0;
+				else
+					id_without_flags++;
+			}
+			pointer_can_pdu->id = id_flags | id_without_flags;
+
+			// Increment the payload bytes
+			for (i = 0; i < pointer_can_pdu->length; i++)
+				pointer_can_pdu->sdu[i]++;
+
+			// Send the incremented frame back
+			CanIf_Transmit(0, &pdu_info);
+		}
+	}
+}
diff --git a/examples/renesas/sample/sample.c b/examples/renesas/sample/sample.c
index ce9420bf..9d6bbf96 100644
--- a/examples/renesas/sample/sample.c
+++ b/examples/renesas/sample/sample.c
@@ -3,11 +3,13 @@
 
 extern void memory_unlocker(void);
 extern void iccom_init(void);
+extern int can_demo_init(void);
 
 FUNC(int, OS_APPL_CODE) main(void)
 {
 	Serial_Init();
 	iccom_init();
+	can_demo_init();
 	memory_unlocker();
 	StartOS(OSDEFAULTAPPMODE);
 	return 0;
diff --git a/examples/renesas/sample/sample.oil b/examples/renesas/sample/sample.oil
index b05b0b3e..a4d42b72 100644
--- a/examples/renesas/sample/sample.oil
+++ b/examples/renesas/sample/sample.oil
@@ -20,6 +20,7 @@ CPU iccom {
       TRAMPOLINE_BASE_PATH = "../../../";
       APP_NAME = "sample_exe";
       APP_SRC = "sample.c";
+      APP_SRC = "can_demo.c";
       APP_SRC = "memory_unlocker.c";
       APP_SRC = "iccom.c";
       APP_SRC = "iccom_ll.c"; 
@@ -42,6 +43,7 @@ CPU iccom {
       LINKER = "rlink";
       SYSTEM = CMAKE;
       LIBRARY = serial;
+      LIBRARY = can;
     };
     SYSTEM_CALL = TRUE;
   };
@@ -73,4 +75,14 @@ CPU iccom {
     TICKSPERBASE = 1;
     MINCYCLE = 1;
   };
+
+  TASK can_task {
+    PRIORITY = 1;
+    AUTOSTART = TRUE {
+             APPMODE = std;
+    };
+    ACTIVATION = 1;
+    SCHEDULE = FULL;
+  };
+
 };
-- 
2.25.1

