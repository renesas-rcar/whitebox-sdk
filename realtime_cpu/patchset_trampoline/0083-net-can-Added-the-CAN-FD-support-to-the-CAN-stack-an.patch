From 0c15ed397d9fbce5fc64598ec759c2fd9e7cd364 Mon Sep 17 00:00:00 2001
From: Adrien Ricciardi <aricciardi@baylibre.com>
Date: Tue, 26 Sep 2023 13:03:09 +0200
Subject: [PATCH 10/38] net: can: Added the CAN-FD support to the CAN stack and
 updated the POSIX CAN demo accordingly.

Breaking API changes have been done to make the CAN configuration easier in a Trampoline application.

Signed-off-by: Adrien Ricciardi <aricciardi@baylibre.com>
---
 examples/posix/can_demo/can_demo.c   | 98 +++++++++++++++++++++++-----
 examples/posix/can_demo/can_demo.oil |  3 +-
 machines/posix/tpl_can_demo_driver.c | 77 ++++++++++++++--------
 net/can/Can.h                        |  3 +-
 net/can/Can_GeneralTypes.h           | 35 +++++++++-
 net/can/tpl_can_core.c               | 69 ++++++++++----------
 6 files changed, 204 insertions(+), 81 deletions(-)

diff --git a/examples/posix/can_demo/can_demo.c b/examples/posix/can_demo/can_demo.c
index 53402544..6ce93f37 100644
--- a/examples/posix/can_demo/can_demo.c
+++ b/examples/posix/can_demo/can_demo.c
@@ -1,3 +1,29 @@
+/**
+ * @file can_demo.c
+ *
+ * @section desc File description
+ *
+ * Test most of the CAN and CAN-FD stack functions using the POSIX virtual
+ * environment and a stub driver.
+ *
+ * @section copyright Copyright
+ *
+ * Trampoline OS
+ *
+ * Trampoline is copyright (c) IRCCyN 2005+
+ * Trampoline is protected by the French intellectual property law.
+ *
+ * (C) BayLibre 2023
+ *
+ * This software is distributed under the Lesser GNU Public Licence
+ *
+ *  @section infos File informations
+ *
+ *  $Date$
+ *  $Rev$
+ *  $Author$
+ *  $URL$
+ */
 #include <Can.h>
 #include <CanIf.h>
 #include <stdio.h>
@@ -7,16 +33,29 @@
 
 int main(void)
 {
-	// Statically list the CAN controllers to use in the application
-	static tpl_can_controller_t *can_controllers[] =
+	// Statically list the configuration of each CAN controller used in the
+	// application
+	static tpl_can_controller_config_t can_controllers_config[] =
 	{
-		&can_demo_driver_controller_1,
-		&can_demo_driver_controller_2,
-		NULL
+		// First controller will use CAN 2.0
+		{
+			&can_demo_driver_controller_1,
+			CAN_PROTOCOL_VERSION_CLASSIC,
+			CAN_BAUD_RATE_250_KBPS,
+			CAN_BAUD_RATE_250_KBPS // This value is ignored for classic CAN
+		},
+		// Second controller will use CAN FD with bit rate switch
+		{
+			&can_demo_driver_controller_2,
+			CAN_PROTOCOL_VERSION_FD,
+			CAN_BAUD_RATE_1_MBPS,
+			CAN_BAUD_RATE_5_MBPS
+		}
 	};
 	static Can_ConfigType can_config_type =
 	{
-		can_controllers
+		can_controllers_config,
+		sizeof(can_controllers_config) / sizeof(can_controllers_config[0])
 	};
 	int ret;
 
@@ -28,14 +67,6 @@ int main(void)
 		return -1;
 	}
 
-	printf("Setting first controller baud rate...\r\n");
-	ret = CanIf_SetBaudrate(0, CAN_BAUD_RATE_500_KBPS);
-	if (ret)
-	{
-		printf("[%s:%d] Error : CanIf_SetBaudrate() failed (%d).\r\n", __func__, __LINE__, ret);
-		return -1;
-	}
-
 	StartOS(OSDEFAULTAPPMODE);
 	return 0;
 }
@@ -43,7 +74,7 @@ int main(void)
 TASK(can_task)
 {
 	Std_ReturnType ret;
-	uint8 payload[8];
+	uint8 payload[64];
 	Can_PduType can_pdu, *pointer_can_pdu;
 	PduInfoType pdu_info;
 	int i;
@@ -69,11 +100,46 @@ TASK(can_task)
 		printf("A frame has been received.\r\n");
 
 		pointer_can_pdu = (Can_PduType *) pdu_info.SduDataPtr;
-		printf("ID = 0x%X, length = %d, payload = ", pointer_can_pdu->id, pointer_can_pdu->length);
+		printf("ID = 0x%X, flags = 0x%02X, length = %d, payload = ",
+			pointer_can_pdu->id & TPL_CAN_ID_MASK,
+			TPL_CAN_ID_TYPE_GET(pointer_can_pdu->id),
+			pointer_can_pdu->length);
 		for (i = 0; i < pointer_can_pdu->length; i++)
 			printf("0x%02X ", pointer_can_pdu->sdu[i]);
 		printf("\r\n");
 	}
 
+	printf("Transmitting a CAN-FD frame with extended ID...\r\n");
+	can_pdu.id = 0xABCD123 | TPL_CAN_ID_TYPE_FD_EXTENDED;
+	strcpy((char *) payload, "This is a longer string.");
+	can_pdu.length = strlen((char *) payload); // The FD length will be automatically adapted by the driver
+	can_pdu.sdu = payload;
+	pdu_info.SduDataPtr = (uint8 *) &can_pdu;
+	pdu_info.SduLength = sizeof(can_pdu);
+	ret = CanIf_Transmit(1, &pdu_info);
+	if (ret)
+		printf("[%s:%d] Error : failed to transmit the frame (%d).\r\n", __func__, __LINE__, ret);
+	printf("Transmission succeeded.\r\n");
+
+	printf("Waiting for a CAN-FD frame with extended ID...\r\n");
+	ret = CanIf_ReadRxPduData(1, &pdu_info);
+	if (ret)
+		printf("No frame is available.\r\n");
+	else
+	{
+		printf("A frame has been received.\r\n");
+
+		pointer_can_pdu = (Can_PduType *) pdu_info.SduDataPtr;
+		printf("ID = 0x%X, flags = 0x%02X, length = %d, payload = ",
+			pointer_can_pdu->id & TPL_CAN_ID_MASK,
+			TPL_CAN_ID_TYPE_GET(pointer_can_pdu->id),
+			pointer_can_pdu->length);
+		for (i = 0; i < pointer_can_pdu->length; i++)
+			printf("0x%02X ", pointer_can_pdu->sdu[i]);
+		printf("\r\n");
+	}
+
+	printf("\r\nEnd of the CAN demo. Press 'q' to exit.\r\n");
+
 	TerminateTask();
 }
diff --git a/examples/posix/can_demo/can_demo.oil b/examples/posix/can_demo/can_demo.oil
index d049792d..1dcc83ba 100644
--- a/examples/posix/can_demo/can_demo.oil
+++ b/examples/posix/can_demo/can_demo.oil
@@ -1,4 +1,4 @@
-OIL_VERSION = "2.5";
+OIL_VERSION = "4.2";
 
 CPU can_task {
 	OS config {
@@ -6,6 +6,7 @@ CPU can_task {
 		BUILD = TRUE {
 			APP_SRC = "can_demo.c";
 			TRAMPOLINE_BASE_PATH = "../../..";
+			CFLAGS = "-W -Wall";
 			LDFLAGS = "-lrt -lpthread";
 			APP_NAME = "can_demo_exe";
 			LINKER = "gcc";
diff --git a/machines/posix/tpl_can_demo_driver.c b/machines/posix/tpl_can_demo_driver.c
index d9c7d585..60830037 100644
--- a/machines/posix/tpl_can_demo_driver.c
+++ b/machines/posix/tpl_can_demo_driver.c
@@ -27,13 +27,34 @@
 #include <stdio.h>
 #include <string.h>
 #include <tpl_can_demo_driver.h>
+#include <tpl_os.h>
 
-static int can_demo_driver_init(struct tpl_can_controller_t *ctrl, void *data);
+static int can_demo_driver_init(struct tpl_can_controller_config_t *config);
 static int can_demo_driver_set_baudrate(struct tpl_can_controller_t *ctrl, tpl_can_baud_rate_t baud_rate);
 static Std_ReturnType can_demo_driver_transmit(struct tpl_can_controller_t *ctrl, const Can_PduType *pdu_info);
 static Std_ReturnType can_demo_driver_receive(struct tpl_can_controller_t *ctrl, Can_PduType *pdu_info);
 static int can_demo_driver_is_data_available(struct tpl_can_controller_t *ctrl);
 
+static uint32 baud_rate_lut[CAN_BAUD_RATE_COUNT] =
+{
+	// CAN_BAUD_RATE_50_KBPS
+	50000,
+	// CAN_BAUD_RATE_100_KBPS
+	100000,
+	// CAN_BAUD_RATE_125_KBPS
+	125000,
+	// CAN_BAUD_RATE_250_KBPS
+	250000,
+	// CAN_BAUD_RATE_500_KBPS
+	500000,
+	// CAN_BAUD_RATE_1_MBPS
+	1000000,
+	// CAN_BAUD_RATE_2_MBPS
+	2000000,
+	// CAN_BAUD_RATE_5_MBPS
+	5000000
+};
+
 tpl_can_controller_t can_demo_driver_controller_1 =
 {
 	0x12341111,
@@ -54,31 +75,22 @@ tpl_can_controller_t can_demo_driver_controller_2 =
 	can_demo_driver_is_data_available
 };
 
-static int can_demo_driver_init(struct tpl_can_controller_t *ctrl, void *data)
+static int can_demo_driver_init(struct tpl_can_controller_config_t *config)
 {
-	(void) data;
-
-	printf("[%s:%d] Initialized controller 0x%08X.\r\n", __func__, __LINE__, ctrl->base_address);
+	printf("[%s:%d] Initializing controller 0x%08X...\r\n",
+		__func__,
+		__LINE__,
+		config->controller->base_address);
+	printf("Protocol version : %s\r\nNominal baud rate : %u\r\n",
+		config->protocol_version == CAN_PROTOCOL_VERSION_CLASSIC ? "CAN classic 2.0" : "CAN-FD",
+		baud_rate_lut[config->nominal_baud_rate]);
+	if (config->protocol_version == CAN_PROTOCOL_VERSION_FD)
+		printf("Data baud rate (only for CAN-FD) : %u\r\n", baud_rate_lut[config->fd_data_baud_rate]);
 	return 0;
 }
 
 static int can_demo_driver_set_baudrate(struct tpl_can_controller_t *ctrl, tpl_can_baud_rate_t baud_rate)
 {
-	static uint32 baud_rate_lut[] =
-	{
-		// CAN_BAUD_RATE_50_KBPS
-		50000,
-		// CAN_BAUD_RATE_100_KBPS
-		100000,
-		// CAN_BAUD_RATE_125_KBPS
-		125000,
-		// CAN_BAUD_RATE_250_KBPS
-		250000,
-		// CAN_BAUD_RATE_500_KBPS
-		500000,
-		// CAN_BAUD_RATE_1_MBPS
-		1000000
-	};
 	uint32 bits_per_second;
 
 	if (baud_rate >= CAN_BAUD_RATE_COUNT)
@@ -97,7 +109,12 @@ static Std_ReturnType can_demo_driver_transmit(struct tpl_can_controller_t *ctrl
 	uint32 i;
 
 	printf("[%s:%d] Transmission request for controller 0x%08X, CAN ID = 0x%X, flags = 0x%02X, payload length = %u, payload = ",
-		   __func__, __LINE__, ctrl->base_address, pdu_info->id & ~TPL_CAN_ID_TYPE_MASK, pdu_info->length, pdu_info->id >> 30);
+		__func__,
+		__LINE__,
+		ctrl->base_address,
+		pdu_info->id & TPL_CAN_ID_MASK,
+		TPL_CAN_ID_TYPE_GET(pdu_info->id),
+		pdu_info->length);
 	for (i = 0; i < pdu_info->length; i++)
 		printf("0x%02X ", pdu_info->sdu[i]);
 	printf("\r\n");
@@ -107,12 +124,20 @@ static Std_ReturnType can_demo_driver_transmit(struct tpl_can_controller_t *ctrl
 
 static Std_ReturnType can_demo_driver_receive(struct tpl_can_controller_t *ctrl, Can_PduType *pdu_info)
 {
-	(void) ctrl;
+	if (ctrl->base_address == can_demo_driver_controller_1.base_address)
+	{
+		pdu_info->id = 0x1ab | TPL_CAN_ID_TYPE_STANDARD; // Random value
+		strcpy((char *) pdu_info->sdu, "Test");
+		pdu_info->length = strlen((char *) pdu_info->sdu);
+	}
+	else if (ctrl->base_address == can_demo_driver_controller_2.base_address)
+	{
+		pdu_info->id = 0xcafeb0b | TPL_CAN_ID_TYPE_FD_EXTENDED; // Random value
+		strcpy((char *) pdu_info->sdu, "The CAN-FD frame longer payload.");
+		pdu_info->length = strlen((char *) pdu_info->sdu);
+	}
 
-	pdu_info->id = 0x1ab; // Random value
-	strcpy((char *) pdu_info->sdu, "Test");
-	pdu_info->length = strlen((char *) pdu_info->sdu);
-	return 0;
+	return E_OK;
 }
 
 static int can_demo_driver_is_data_available(struct tpl_can_controller_t *ctrl)
diff --git a/net/can/Can.h b/net/can/Can.h
index 1ffa71f3..b1456c8f 100644
--- a/net/can/Can.h
+++ b/net/can/Can.h
@@ -38,7 +38,8 @@
  */
 typedef struct
 {
-	tpl_can_controller_t **controllers_list;
+	tpl_can_controller_config_t *configs;
+	unsigned int configs_count;
 } Can_ConfigType;
 
 /**
diff --git a/net/can/Can_GeneralTypes.h b/net/can/Can_GeneralTypes.h
index 69b2163c..73d7af46 100644
--- a/net/can/Can_GeneralTypes.h
+++ b/net/can/Can_GeneralTypes.h
@@ -34,6 +34,8 @@
 #define TPL_CAN_ID_TYPE_EXTENDED (0x02 << 30)
 #define TPL_CAN_ID_TYPE_FD_EXTENDED (0x03 << 30)
 #define TPL_CAN_ID_TYPE_MASK (0x03 << 30)
+#define TPL_CAN_ID_TYPE_GET(id) ((id & TPL_CAN_ID_TYPE_MASK) >> 30)
+#define TPL_CAN_ID_MASK (0x3FFFFFFF)
 
 /**
  * @note This will be replaced by a table provided to Can_Init() with
@@ -47,9 +49,24 @@ typedef enum
 	CAN_BAUD_RATE_250_KBPS,
 	CAN_BAUD_RATE_500_KBPS,
 	CAN_BAUD_RATE_1_MBPS,
+	CAN_BAUD_RATE_2_MBPS,
+	CAN_BAUD_RATE_5_MBPS,
 	CAN_BAUD_RATE_COUNT
 } tpl_can_baud_rate_t;
 
+/**
+ * @typedef tpl_can_protocol_version_t
+ *
+ * Select the version of the CAN protocol to operate for a specific CAN
+ * controller.
+ */
+typedef enum
+{
+	CAN_PROTOCOL_VERSION_CLASSIC,
+	CAN_PROTOCOL_VERSION_FD,
+	CAN_PROTOCOL_VERSION_XL
+} tpl_can_protocol_version_t;
+
 /**
  * @typedef Can_IdType
  *
@@ -79,6 +96,7 @@ typedef struct
 	uint8 *sdu;
 } Can_PduType;
 
+struct tpl_can_controller_config_t;
 /**
  * @struct tpl_can_controller_t
  *
@@ -88,8 +106,7 @@ typedef struct
 struct tpl_can_controller_t
 {
 	uint32 base_address;
-	tpl_can_baud_rate_t initial_baud_rate;
-	int (*init)(struct tpl_can_controller_t *ctrl, void *data);
+	int (*init)(struct tpl_can_controller_config_t *config);
 	int (*set_baudrate)(struct tpl_can_controller_t *ctrl, tpl_can_baud_rate_t baud_rate);
 	Std_ReturnType (*transmit)(struct tpl_can_controller_t *ctrl, const Can_PduType *pdu_info);
 	Std_ReturnType (*receive)(struct tpl_can_controller_t *ctrl, Can_PduType *pdu_info);
@@ -97,6 +114,20 @@ struct tpl_can_controller_t
 };
 typedef struct tpl_can_controller_t tpl_can_controller_t;
 
+/**
+ * @struct tpl_can_controller_config_t
+ *
+ * Associate a CAN controller and its configuration for the current application.
+ */
+struct tpl_can_controller_config_t
+{
+	tpl_can_controller_t *controller;
+	tpl_can_protocol_version_t protocol_version;
+	tpl_can_baud_rate_t nominal_baud_rate; // The classic CAN baud rate, or the arbitration baud rate when in CAN FD mode
+	tpl_can_baud_rate_t fd_data_baud_rate; // The data baud rate for CAN-FD when bit rate switch is set, this value is ignored for classic CAN
+};
+typedef struct tpl_can_controller_config_t tpl_can_controller_config_t;
+
 /**
  * @typedef Can_HwHandleType
  *
diff --git a/net/can/tpl_can_core.c b/net/can/tpl_can_core.c
index 5c55d3ca..770ae82b 100644
--- a/net/can/tpl_can_core.c
+++ b/net/can/tpl_can_core.c
@@ -27,37 +27,39 @@
 #include <CanIf.h>
 #include <tpl_os_definitions.h>
 
-static tpl_can_controller_t **controllers_list;
-static int controllers_count;
+static tpl_can_controller_config_t *controller_configs;
+static unsigned int controllers_count;
 
 int Can_Init(const Can_ConfigType *Config)
 {
-	int i, ret;
-	tpl_can_controller_t **ctrl_list, *ctrl;
+	int ret;
+	unsigned int i;
+	tpl_can_controller_config_t *config;
+	tpl_can_controller_t *controller;
 
-	controllers_list = Config->controllers_list;
-	controllers_count = 0;
-	ctrl_list = controllers_list;
-	while ((ctrl = *ctrl_list) != NULL)
+	controller_configs = Config->configs;
+	controllers_count = Config->configs_count;
+
+	for (i = 0; i < controllers_count; i++)
 	{
+		config = &controller_configs[i];
+		controller = config->controller;
+
 		// Make sure all callback functions are provided (check only once here to avoid checking later at every function call)
-		if (!ctrl->init)
+		if (!controller->init)
 			return -5;
-		if (!ctrl->set_baudrate)
+		if (!controller->set_baudrate)
 			return -5;
-		if (!ctrl->transmit)
+		if (!controller->transmit)
 			return -5;
-		if (!ctrl->receive)
+		if (!controller->receive)
 			return -5;
-		if (!ctrl->is_data_available)
+		if (!controller->is_data_available)
 			return -5;
 
-		ret = ctrl->init(ctrl, NULL);
+		ret = controller->init(config);
 		if (ret)
 			return ret;
-
-		ctrl_list++;
-		controllers_count++;
 	}
 
 	return 0;
@@ -65,36 +67,33 @@ int Can_Init(const Can_ConfigType *Config)
 
 Std_ReturnType Can_SetBaudrate(uint8 Controller, uint16 BaudRateConfigID)
 {
-	tpl_can_controller_t *ctrl;
+	tpl_can_controller_t *controller;
 
 	// Make sure the controller has been registered and initialized
 	if (Controller >= controllers_count)
 		return E_NOT_OK;
-	ctrl = controllers_list[Controller];
+	controller = controller_configs[Controller].controller;
 
-	if (ctrl->set_baudrate(ctrl, BaudRateConfigID))
+	if (controller->set_baudrate(controller, BaudRateConfigID))
 		return E_NOT_OK;
 	return E_OK;
 }
 
 Std_ReturnType Can_Write(Can_HwHandleType Hth, const Can_PduType *PduInfo)
 {
-	tpl_can_controller_t *ctrl = Hth;
+	tpl_can_controller_t *controller = Hth;
 	Std_ReturnType ret = E_NOT_OK;
 
-	if (ctrl == NULL)
+	if (controller == NULL)
 		return E_NOT_OK;
 
-	if (ctrl->transmit)
-		ret = ctrl->transmit(ctrl, PduInfo);
+	// No need to check for the transmit callback presence, this has already been done by Can_Init()
+	ret = controller->transmit(controller, PduInfo);
 
 	return ret;
 }
 
-void CanIf_Init(void)
-{
-	// TODO, maybe flags to enable CAN FD
-}
+void CanIf_Init(void) {}
 
 Std_ReturnType CanIf_SetBaudrate(uint8 ControllerId, uint16 BaudRateConfigID)
 {
@@ -105,31 +104,31 @@ Std_ReturnType CanIf_SetBaudrate(uint8 ControllerId, uint16 BaudRateConfigID)
 
 Std_ReturnType CanIf_Transmit(PduIdType TxPduId, const PduInfoType *PduInfoPtr)
 {
-	tpl_can_controller_t *ctrl;
+	tpl_can_controller_t *controller;
 	Can_PduType *can_pdu;
 
 	// Make sure the controller has been registered and initialized
 	if (TxPduId >= controllers_count)
 		return E_NOT_OK;
-	ctrl = controllers_list[TxPduId];
+	controller = controller_configs[TxPduId].controller;
 
 	can_pdu = (Can_PduType *) PduInfoPtr->SduDataPtr;
-	return Can_Write(ctrl, can_pdu);
+	return Can_Write(controller, can_pdu);
 }
 
 Std_ReturnType CanIf_ReadRxPduData(PduIdType CanIfRxSduId, PduInfoType *CanIfRxInfoPtr)
 {
-	tpl_can_controller_t *ctrl;
+	tpl_can_controller_t *controller;
 	Can_PduType *can_pdu;
 
 	// Make sure the controller has been registered and initialized
 	if (CanIfRxSduId >= controllers_count)
 		return E_NOT_OK;
-	ctrl = controllers_list[CanIfRxSduId];
+	controller = controller_configs[CanIfRxSduId].controller;
 
-	if (!ctrl->is_data_available(ctrl))
+	if (!controller->is_data_available(controller))
 		return E_NOT_OK;
 
 	can_pdu = (Can_PduType *) CanIfRxInfoPtr->SduDataPtr;
-	return ctrl->receive(ctrl, can_pdu);
+	return controller->receive(controller, can_pdu);
 }
-- 
2.34.1

