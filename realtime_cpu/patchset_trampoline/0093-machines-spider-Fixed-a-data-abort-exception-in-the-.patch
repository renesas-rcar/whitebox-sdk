From 043f1967eac664a63e44eb6fe4600f1a272967e7 Mon Sep 17 00:00:00 2001
From: Adrien Ricciardi <aricciardi@baylibre.com>
Date: Tue, 3 Oct 2023 13:59:27 +0200
Subject: [PATCH 20/38] machines: spider: Fixed a data abort exception in the
 CAN driver triggered by a 7-byte payload frame.

Receiving a CAN 2.0 frame with a 7-byte payload triggered a data abort exception.
This exception was due to the usage of memcpy() to copy the data from and to the
CAN controller registers.

Maybe the memcpy() has some internal optimization that copies 4 bytes at a time,
then single bytes, and these non uniform accesses were messing up the hardware.

Signed-off-by: Adrien Ricciardi <aricciardi@baylibre.com>
---
 .../armv8/spider/drivers/can/spider_can.c     | 26 +++++++++++++++++--
 1 file changed, 24 insertions(+), 2 deletions(-)

diff --git a/machines/cortex-a/armv8/spider/drivers/can/spider_can.c b/machines/cortex-a/armv8/spider/drivers/can/spider_can.c
index e4b22789..e5740fe6 100644
--- a/machines/cortex-a/armv8/spider/drivers/can/spider_can.c
+++ b/machines/cortex-a/armv8/spider/drivers/can/spider_can.c
@@ -190,6 +190,8 @@ static int spider_set_baudrate(struct tpl_can_controller_t *ctrl, CanControllerB
 static Std_ReturnType spider_transmit(struct tpl_can_controller_t *ctrl, const Can_PduType *pdu_info)
 {
 	volatile struct __tag5586 *ctrl_base_address = (volatile struct __tag5586 *) ctrl->base_address;
+	int i;
+	volatile uint8 *src, *dest;
 
 	if (ctrl == NULL)
 		return E_NOT_OK;
@@ -209,7 +211,16 @@ static Std_ReturnType spider_transmit(struct tpl_can_controller_t *ctrl, const C
 	// Set the frame payload
 	if (pdu_info->length > 8)
 		return E_NOT_OK;
-	memcpy((void *) &ctrl_base_address->CFD0TMDF0_0.UINT8, pdu_info->sdu, pdu_info->length);
+	src = pdu_info->sdu;
+	dest = ctrl_base_address->CFD0TMDF0_0.UINT8;
+	// Use a for loop instead of memcpy() to make sure the buffer registers are accessed one byte at a time
+	// Using memcpy() triggers a data abort exception for a 7-byte CAN payload
+	for (i = 0; i < pdu_info->length; i++)
+	{
+		*dest = *src;
+		src++;
+		dest++;
+	}
 
 	// Configure the frame format
 	ctrl_base_address->CFD0TMFDCTR0.UINT32 = 0;
@@ -223,6 +234,8 @@ static Std_ReturnType spider_transmit(struct tpl_can_controller_t *ctrl, const C
 static Std_ReturnType spider_receive(struct tpl_can_controller_t *ctrl, Can_PduType *pdu_info)
 {
 	volatile struct __tag5586 *ctrl_base_address = (volatile struct __tag5586 *) ctrl->base_address;
+	int i;
+	volatile uint8 *src, *dest;
 
 	// Do not block if no data are available
 	if (!SPIDER_CAN_RECEIVED_DATA_FLAG(ctrl))
@@ -237,7 +250,16 @@ static Std_ReturnType spider_receive(struct tpl_can_controller_t *ctrl, Can_PduT
 		goto Exit;
 
 	// Retrieve the frame payload
-	memcpy(pdu_info->sdu, (void *) &ctrl_base_address->CFDRMDF0_0.UINT8, pdu_info->length);
+	src = ctrl_base_address->CFDRMDF0_0.UINT8;
+	dest = pdu_info->sdu;
+	// Use a for loop instead of memcpy() to make sure the buffer registers are accessed one byte at a time
+	// Using memcpy() triggers a data abort exception for a 7-byte CAN payload
+	for (i = 0; i < pdu_info->length; i++)
+	{
+		*dest = *src;
+		src++;
+		dest++;
+	}
 
 Exit:
 	// Clear the reception flag
-- 
2.34.1

