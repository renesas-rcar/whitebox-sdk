From 8b850b6f7b41e877ea5ade46d11ecef3f828b208 Mon Sep 17 00:00:00 2001
From: Florian Sylvestre <fsylvestre@baylibre.com>
Date: Tue, 25 Apr 2023 15:51:15 +0200
Subject: [PATCH 04/13] add support for ARMV8-CortexR52-Spider platform

Basic support for Spider platform: without interrupt support
---
 .../armv8/interrupt_table.goilTemplate        | 180 ++++++++++
 .../armv8/process_specific.goilTemplate       |  42 +++
 .../cortex-a/armv8/service_call.goilTemplate  |   7 +
 .../armv8/spider/counter_call.goilTemplate    |  38 +++
 .../armv8/std_as_code_dir.goilTemplate        |   3 +
 .../cortex-a/armv8/tpl_invoque_s.goilTemplate |   7 +
 .../config/cortex-a/armv8/config.oil          |   7 +
 .../config/cortex-a/armv8/sensibility.oil     |   2 +
 .../cortex-a/armv8/spider/buildOptions.oil    |  44 +++
 .../config/cortex-a/armv8/spider/config.oil   |  80 +++++
 .../armv8/spider/interruptSources.oil         |  43 +++
 .../config/cortex-a/armv8/spider/pins.oil     |   2 +
 .../cortex-a/armv8/spider/script.goilTemplate |  67 ++++
 .../cortex-a/armv8/spider/bootstrap_stage1.S  | 312 ++++++++++++++++++
 .../cortex-a/armv8/spider/bootstrap_stage2.c  |  65 ++++
 .../cortex-a/armv8/spider/handlers_spider.c   |  68 ++++
 .../cortex-a/armv8/spider/handlers_spider.h   |  35 ++
 machines/cortex-a/armv8/spider/tpl_irq.c      |  56 ++++
 .../armv8/spider/tpl_machine_spider.c         | 110 ++++++
 .../cortex-a/armv8/spider/tpl_stacks_size.h   |  40 +++
 machines/cortex-a/armv8/spider/tpl_stubs.c    |  62 ++++
 .../armv8/spider/tpl_vector_table_ns.s        |  30 ++
 22 files changed, 1300 insertions(+)
 create mode 100755 goil/templates/code/cortex-a/armv8/interrupt_table.goilTemplate
 create mode 100755 goil/templates/code/cortex-a/armv8/process_specific.goilTemplate
 create mode 100755 goil/templates/code/cortex-a/armv8/service_call.goilTemplate
 create mode 100755 goil/templates/code/cortex-a/armv8/spider/counter_call.goilTemplate
 create mode 100755 goil/templates/code/cortex-a/armv8/std_as_code_dir.goilTemplate
 create mode 100755 goil/templates/code/cortex-a/armv8/tpl_invoque_s.goilTemplate
 create mode 100755 goil/templates/config/cortex-a/armv8/config.oil
 create mode 100755 goil/templates/config/cortex-a/armv8/sensibility.oil
 create mode 100755 goil/templates/config/cortex-a/armv8/spider/buildOptions.oil
 create mode 100755 goil/templates/config/cortex-a/armv8/spider/config.oil
 create mode 100755 goil/templates/config/cortex-a/armv8/spider/interruptSources.oil
 create mode 100755 goil/templates/config/cortex-a/armv8/spider/pins.oil
 create mode 100644 goil/templates/linker/gnu_ld/cortex-a/armv8/spider/script.goilTemplate
 create mode 100644 machines/cortex-a/armv8/spider/bootstrap_stage1.S
 create mode 100644 machines/cortex-a/armv8/spider/bootstrap_stage2.c
 create mode 100644 machines/cortex-a/armv8/spider/handlers_spider.c
 create mode 100644 machines/cortex-a/armv8/spider/handlers_spider.h
 create mode 100644 machines/cortex-a/armv8/spider/tpl_irq.c
 create mode 100644 machines/cortex-a/armv8/spider/tpl_machine_spider.c
 create mode 100644 machines/cortex-a/armv8/spider/tpl_stacks_size.h
 create mode 100644 machines/cortex-a/armv8/spider/tpl_stubs.c
 create mode 100644 machines/cortex-a/armv8/spider/tpl_vector_table_ns.s

diff --git a/goil/templates/code/cortex-a/armv8/interrupt_table.goilTemplate b/goil/templates/code/cortex-a/armv8/interrupt_table.goilTemplate
new file mode 100755
index 00000000..23521de5
--- /dev/null
+++ b/goil/templates/code/cortex-a/armv8/interrupt_table.goilTemplate
@@ -0,0 +1,180 @@
+#include "tpl_machine.h"
+
+%
+%
+#define OS_START_SEC_CODE
+#include "tpl_memmap.h"
+%
+
+#------------------------------------------------------------------------------*
+# Target specific initializations
+# build the maps for IRQ
+#
+let INTERRUPT_SOURCE_MAP := mapof INTERRUPT_SOURCE by NAME
+
+let objForSRC := emptymap
+
+# Map ISR into objForSRC
+foreach isr in ISR do
+  let key := isr::SOURCE
+  display key
+  if not exists objForSRC[key] then
+    let objForSRC[key] := emptylist
+  end if
+  let isr::KIND := "ISR"
+#  let isr::ACK := INTERRUPT_SOURCE_MAP[key]::ACK
+  let objForSRC[key] += isr
+end foreach
+
+# Map COUNTER into objForSRC
+foreach cnt in COUNTER do
+  let key := cnt::SOURCE
+  if not exists objForSRC[key] then
+    let objForSRC[key] := emptylist
+  end if
+  let cnt::KIND := "COUNTER"
+#  display INTERRUPTMAP[key]
+#  let cnt::ACK := INTERRUPT_SOURCE_MAP[key]::ACK
+  let objForSRC[key] += cnt
+# display objForSRC[key]
+end foreach
+
+# Build the list of counters to call
+let counterForIRQ := emptymap
+
+# Build a list of virtual objects (counters) each of them holding values :
+# handlerSource, handlerName, handlerAck, generatePrimaryIrq
+foreach objList in objForSRC do
+  foreach obj in objList do
+    if obj::KIND == "COUNTER" then
+      let counterForIRQ[KEY] := emptylist
+    end if
+  end foreach
+  foreach obj in objList do
+    if obj::KIND == "COUNTER" then
+      let  counterForIRQ[KEY] += obj::NAME
+    end if
+  end foreach
+end foreach
+
+#------------------------------------------------------------------------------*
+let INTERRUPTMAP := mapof INTERRUPT_SOURCE by NAME
+
+foreach objList in objForSRC do
+  let handlerAck := false
+  let objList_KEY := KEY
+  let indexISR2 := 0
+  foreach obj in objList do
+    if INTERRUPTMAP[KEY]::ACK then
+      let handlerAck := true
+    end if
+    if obj::KIND == "ISR" then
+      if obj::CATEGORY == 1 then
+%  extern FUNC(void, OS_CODE) % !obj::NAME %_function(void);
+%
+      end if
+    end if
+
+    if handlerAck then
+%  extern FUNC(void, OS_CODE) %!objList_KEY%_ClearFlag(void);
+%
+    end if
+  end foreach
+end foreach
+
+foreach objList in objForSRC do
+  let objList_KEY := KEY
+%
+FUNC(void, OS_CODE) % !objList_KEY %_Handler(void)
+{
+%
+  let indexISR2 := 0
+  foreach obj in objList do
+    if obj::KIND == "ISR" then
+# ISR 1
+      if obj::CATEGORY == 1 then
+%
+  % !obj::NAME %_function();
+%
+      else
+        if obj::CATEGORY == 2 then
+# ISR2
+%
+  tpl_central_interrupt_handler(% !([TASKS length] + indexISR2) %);
+%
+          let indexISR2 := indexISR2 + 1
+        else
+          error obj::CATEGORY : "This interrupt category ".obj::CATEGORY." does not exist"
+        end if
+      end if
+    end if
+  end foreach
+  foreach objCounter in counterForIRQ do
+    let objCounter_KEY := KEY
+    if objCounter_KEY == objList_KEY then
+      %  tpl_tick_% !objCounter_KEY %();
+%
+    end if
+  end foreach
+  let ackDone := false
+  foreach obj in objList do
+    if not ackDone then
+#      if obj::ACK then
+#        let ackDone := true
+%  %!objList_KEY%_ClearFlag();
+%
+#      end if
+    end if
+  end foreach
+%
+}
+%
+end foreach
+%
+#define OS_STOP_SEC_CODE
+#include "tpl_memmap.h"
+%
+
+%
+
+/* Interrupt table vector */
+%
+%
+#define OS_START_SEC_CODE
+#include "tpl_memmap.h"
+%
+loop ENTRY from 0 to INTERRUPT_COUNT::IT_TABLE_SIZE - 1
+ before
+%
+CONST(tpl_it_vector_entry, OS_CONST) tpl_it_vector[% !INTERRUPT_COUNT::IT_TABLE_SIZE %] = {
+%
+ do
+   let src_found := false
+   foreach src in INTERRUPT_SOURCE do
+     if not src_found then
+       if src::SOURCE_NUM == ENTRY then
+         if exists objForSRC[src::NAME] then
+          let src_found := true
+%  { (tpl_it_handler)% !src::NAME %_Handler, (void *)NULL }%
+         end if
+       end if
+     end if
+     # Il ne doit rien y avoir ici
+   end foreach
+   if not src_found then
+%  { (tpl_it_handler)tpl_null_it, (void *)NULL }%   
+   end if
+ between
+%,
+%
+ after
+%
+};
+% 
+end loop
+%
+#define OS_STOP_SEC_CODE
+#include "tpl_memmap.h"
+%
+
+# vim:ft=goil_templates
diff --git a/goil/templates/code/cortex-a/armv8/process_specific.goilTemplate b/goil/templates/code/cortex-a/armv8/process_specific.goilTemplate
new file mode 100755
index 00000000..3fde5c78
--- /dev/null
+++ b/goil/templates/code/cortex-a/armv8/process_specific.goilTemplate
@@ -0,0 +1,42 @@
+/*
+ * % !proc::KIND % % !proc::NAME % stack
+ */
+%
+if exists task::SECTION then
+%#define % !task::SECTION %_START_SEC_VAR_16BIT%
+else
+%#define APP_% !proc::KIND %_% !proc::NAME %_START_SEC_STACK
+%
+end if
+%
+#include "tpl_memmap.h"
+VAR(tpl_stack_word, OS_APPL_DATA) % !proc::NAME %_stack_zone[% !proc::STACKSIZE %/sizeof(tpl_stack_word)];
+%
+if exists task::SECTION then
+%#define % !task::SECTION %_STOP_SEC_VAR_16BIT%
+else
+%#define APP_% !proc::KIND %_% !proc::NAME %_STOP_SEC_STACK
+%
+end if
+%
+#include "tpl_memmap.h"
+
+#define % !proc::NAME %_STACK {% !proc::NAME %_stack_zone, % !proc::STACKSIZE %}
+
+/*
+ * % !proc::KIND % % !proc::NAME % context
+ */
+#define OS_START_SEC_VAR_NOINIT_32BIT
+#include "tpl_memmap.h"
+VAR(arm_context, OS_VAR) % !proc::NAME %_int_context;
+
+#define % !proc::NAME %_CONTEXT &% !proc::NAME %_int_context
+
+#define OS_STOP_SEC_VAR_NOINIT_32BIT
+#include "tpl_memmap.h"
+%if proc::KIND == "ISR" then 
+    if not exists proc::SOURCE then
+       error proc::NAME : "SOURCE attribute not defined for ".proc::KIND." ".proc::NAME
+    end if
+  end if
+%
diff --git a/goil/templates/code/cortex-a/armv8/service_call.goilTemplate b/goil/templates/code/cortex-a/armv8/service_call.goilTemplate
new file mode 100755
index 00000000..d0d6e1bc
--- /dev/null
+++ b/goil/templates/code/cortex-a/armv8/service_call.goilTemplate
@@ -0,0 +1,7 @@
+  .global % !exists api_func::ACTUAL default ( api_func::NAME ) %
+% !exists api_func::ACTUAL default ( api_func::NAME ) %:
+  stmfd sp!,{lr}
+  mov r3,#% !api_sec::ID_PREFIX %ServiceId_% !api_func::NAME %
+  swi #% !api_sec::ID_PREFIX %ServiceId_% !api_func::NAME %
+  ldmfd sp!,{lr}
+  mov pc,lr
diff --git a/goil/templates/code/cortex-a/armv8/spider/counter_call.goilTemplate b/goil/templates/code/cortex-a/armv8/spider/counter_call.goilTemplate
new file mode 100755
index 00000000..fc505fc9
--- /dev/null
+++ b/goil/templates/code/cortex-a/armv8/spider/counter_call.goilTemplate
@@ -0,0 +1,38 @@
+#include "tpl_os_kernel.h"          /* tpl_schedule */
+#include "tpl_os_timeobj_kernel.h"  /* tpl_counter_tick */
+#include "tpl_machine_interface.h"  /* tpl_switch_context_from_it */
+
+#define OS_START_SEC_CODE
+#include "tpl_memmap.h"
+%
+
+foreach interrupt in INTERRUPT_SOURCE do
+  let counterFct := emptylist
+  foreach counter in COUNTERS do
+    if counter::SOURCE == interrupt::NAME then
+      let counterFct += counter::NAME
+    end if
+  end foreach
+  foreach cpt_fct in counterFct
+    before
+%
+FUNC(void, OS_CODE) tpl_tick_% !interrupt::NAME %()
+{
+%
+    do
+      %  tpl_counter_tick(&% !cpt_fct %_counter_desc);
+%
+    after %
+
+  if (tpl_kern.need_schedule)
+  {
+    tpl_schedule_from_running();
+    LOCAL_SWITCH_CONTEXT()
+  }
+}
+%
+  end foreach
+end foreach
+%
+#define OS_STOP_SEC_CODE
+#include "tpl_memmap.h"
diff --git a/goil/templates/code/cortex-a/armv8/std_as_code_dir.goilTemplate b/goil/templates/code/cortex-a/armv8/std_as_code_dir.goilTemplate
new file mode 100755
index 00000000..bc3be771
--- /dev/null
+++ b/goil/templates/code/cortex-a/armv8/std_as_code_dir.goilTemplate
@@ -0,0 +1,3 @@
+.text
+.code 32
+.align 2
diff --git a/goil/templates/code/cortex-a/armv8/tpl_invoque_s.goilTemplate b/goil/templates/code/cortex-a/armv8/tpl_invoque_s.goilTemplate
new file mode 100755
index 00000000..b8559c1b
--- /dev/null
+++ b/goil/templates/code/cortex-a/armv8/tpl_invoque_s.goilTemplate
@@ -0,0 +1,7 @@
+%
+!PROJECT %/tpl_invoque.S
+%
+write to PROJECT."/tpl_invoque.S":
+  let EXTENSION := "S"
+  template tpl_invoque in code
+end write
\ No newline at end of file
diff --git a/goil/templates/config/cortex-a/armv8/config.oil b/goil/templates/config/cortex-a/armv8/config.oil
new file mode 100755
index 00000000..6343f64c
--- /dev/null
+++ b/goil/templates/config/cortex-a/armv8/config.oil
@@ -0,0 +1,7 @@
+#includeifexists <buildOptions.oil>
+
+CPU armv8 {
+  PLATFORM_FILES armv8 {
+    PATH = "cortex-a/armv8";
+  };
+};
diff --git a/goil/templates/config/cortex-a/armv8/sensibility.oil b/goil/templates/config/cortex-a/armv8/sensibility.oil
new file mode 100755
index 00000000..78c28418
--- /dev/null
+++ b/goil/templates/config/cortex-a/armv8/sensibility.oil
@@ -0,0 +1,2 @@
+ENUM [ RISING, FALLING, BOTH ] TRIGGER = RISING;
+ENUM [ UP, DOWN, NONE ] PULL = NONE;
diff --git a/goil/templates/config/cortex-a/armv8/spider/buildOptions.oil b/goil/templates/config/cortex-a/armv8/spider/buildOptions.oil
new file mode 100755
index 00000000..3a42e549
--- /dev/null
+++ b/goil/templates/config/cortex-a/armv8/spider/buildOptions.oil
@@ -0,0 +1,44 @@
+/*
+ * ARMv8 Cortex-R52 build options for gcc
+ */
+CPU buildOptions {
+  BUILDOPTIONS defaultBuildOptionsForARM8_CortexR52 {
+    /*
+     * Common flags for C and C++ compiling
+     * -Wall -O2 -nostdlib -nostartfiles -ffreestanding
+     */
+//    COMMONFLAGS = "-g";                           // Produce debugging information
+    COMMONFLAGS = "-Wall";                        // All warnings on
+    COMMONFLAGS = "-pedantic";
+    COMMONFLAGS = "-Wformat";
+    COMMONFLAGS = "-std=c99";
+    COMMONFLAGS = "-mcpu=cortex-r52";              // Compile for arm r52
+    COMMONFLAGS = "-Wmissing-field-initializers"; // Struct initialized with incorrect number of fiels
+    COMMONFLAGS = "-mfloat-abi=soft";             // Floating point numbers are computed in software
+
+    /*
+     * C++ compiler flags
+     */
+    CPPFLAGS = "-fno-rtti";                       // No information for runtime (run time type information) - reduce exe size
+    CPPFLAGS = "-felide-constructors";            // Optimization to omit creating temporary object when used to initialize another object
+    CPPFLAGS = "-fno-threadsafe-statics";         // No thread safe init of local static variables - reduce code size
+    CPPFLAGS = "-fno-use-cxa-get-exception-ptr";  // Don't use the __cxa_get_exception_ptr runtime routine (no exception anyway)
+    CPPFLAGS = "-fno-enforce-eh-specs";           // Don't generate code to check for violation of exception specifications at runtime (no exception anyway)
+
+    /*
+     * Assembler flags
+     */
+//    ASFLAGS = "-g";                               // Produce debugging information
+    ASFLAGS = "-mcpu=cortex-r52";                 // Assemble for arm r52
+    ASFLAGS = "--fatal-warnings";                 // A warning is an error
+    ASFLAGS = "-mfloat-abi=soft";                 // Floating point numbers are computed in software gcc-options-to-the-arm-mcu-fpu-datasheet
+
+//    LDFLAGS = "-g";
+    LDFLAGS = "--fatal-warnings";                 // A warning is an error
+    LDFLAGS = "--warn-common";                    // Warn when a common symbol is combined with another common symbol
+    LDFLAGS = "--no-undefined";                   // Report unresolved symbol references
+    LDFLAGS = "--no-warn-rwx-segments";           // 
+
+/*    LDFLAGS = "--gc-sections";                    // Remove unused sections. Works with -ffunction-sections and -fdata-sections, see above*/
+  };
+};
diff --git a/goil/templates/config/cortex-a/armv8/spider/config.oil b/goil/templates/config/cortex-a/armv8/spider/config.oil
new file mode 100755
index 00000000..3cf1ad7d
--- /dev/null
+++ b/goil/templates/config/cortex-a/armv8/spider/config.oil
@@ -0,0 +1,80 @@
+#includeifexists <buildOptions.oil>
+
+/*
+ * Interrupt sources of the board
+ */
+CPU spider {
+  INTERRUPT_COUNT nb_it {
+    IT_TABLE_SIZE = 32;
+  };
+
+  INTERRUPT_VECTOR Reset                 { VECTOR_NUM = 0; VECTOR_KIND = HANDLER { NAME =  ""; }; };
+  INTERRUPT_VECTOR Undefined_Instruction { VECTOR_NUM = 1; VECTOR_KIND = HANDLER { NAME =  ""; }; };
+  INTERRUPT_VECTOR Supervisor_Call       { VECTOR_NUM = 2; VECTOR_KIND = HANDLER { NAME =  ""; }; };
+  INTERRUPT_VECTOR Prefetch_Abort        { VECTOR_NUM = 3; VECTOR_KIND = HANDLER { NAME =  ""; }; };
+  INTERRUPT_VECTOR Data_Abort            { VECTOR_NUM = 4; VECTOR_KIND = HANDLER { NAME =  ""; }; };
+  INTERRUPT_VECTOR Hyp_Trap              { VECTOR_NUM = 5; VECTOR_KIND = HANDLER { NAME =  ""; }; };
+  INTERRUPT_VECTOR IRQ_Interrupt         { VECTOR_NUM = 6; VECTOR_KIND = HANDLER { NAME =  ""; }; };
+  INTERRUPT_VECTOR FIQ_Interrupt         { VECTOR_NUM = 7; VECTOR_KIND = HANDLER { NAME =  ""; }; };
+
+  // TO BE UPDATED
+  INTERRUPT_SOURCE ARM_TIMER             { SOURCE_NUM = 0; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE ARM_MAILBOX           { SOURCE_NUM = 1; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE ARM_DOORBELL_0        { SOURCE_NUM = 2; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE ARM_DOORBELL_1        { SOURCE_NUM = 3; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU0_HALTED           { SOURCE_NUM = 4; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU1_HALTED           { SOURCE_NUM = 5; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE ILLEGAL_ACCESS_TYPE_1 { SOURCE_NUM = 6; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE ILLEGAL_ACCESS_TYPE_0 { SOURCE_NUM = 7; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE AUX_INT               { SOURCE_NUM = 8; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE I2C_SPI_SLV_INT       { SOURCE_NUM = 9; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE PWA0                  { SOURCE_NUM = 10; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE PWA1                  { SOURCE_NUM = 11; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE SMI                   { SOURCE_NUM = 12; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPIO_INT_0            { SOURCE_NUM = 13; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPIO_INT_1            { SOURCE_NUM = 14; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPIO_INT_2            { SOURCE_NUM = 15; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPIO_INT_3            { SOURCE_NUM = 16; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE I2C_INT               { SOURCE_NUM = 17; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE SPI_INT               { SOURCE_NUM = 18; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE PCM_INT               { SOURCE_NUM = 19; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE UART_INT              { SOURCE_NUM = 20; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU_IRQ_7             { SOURCE_NUM = 21; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU_IRQ_9             { SOURCE_NUM = 22; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU_IRQ_10            { SOURCE_NUM = 23; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU_IRQ_18            { SOURCE_NUM = 24; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU_IRQ_19            { SOURCE_NUM = 25; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU_IRQ_53            { SOURCE_NUM = 26; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU_IRQ_54            { SOURCE_NUM = 27; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU_IRQ_55            { SOURCE_NUM = 28; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU_IRQ_56            { SOURCE_NUM = 29; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU_IRQ_57            { SOURCE_NUM = 30; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+  INTERRUPT_SOURCE GPU_IRQ_62            { SOURCE_NUM = 31; VECTOR = IRQ_Interrupt; ACK = TRUE; };
+
+
+  PLATFORM_FILES spider {
+    PATH = "cortex-a/armv8/spider";
+    CFILE = "handlers_spider.c";
+    CFILE = "tpl_machine_spider.c";
+    ASFILE = "bootstrap_stage1.S";
+    CFILE = "bootstrap_stage2.c";
+    CFILE = "tpl_stubs.c";
+    CFILE = "tpl_irq.c";
+    CFILE = "tpl_vector_table_ns.s";
+  };
+
+  POSTBUILD all {
+    COMMAND buildhex {
+      TYPE = COPIER;
+      INPUT = ORIGINAL_TARGET;
+      OUTPUT = ".hex";
+      PREOPTION = "-O ihex";
+    };
+    COMMAND buildbin {
+      TYPE = COPIER;
+      INPUT = ORIGINAL_TARGET;
+      OUTPUT = ".bin";
+      PREOPTION = "-O binary";
+    };
+  };
+};
diff --git a/goil/templates/config/cortex-a/armv8/spider/interruptSources.oil b/goil/templates/config/cortex-a/armv8/spider/interruptSources.oil
new file mode 100755
index 00000000..d0189cf5
--- /dev/null
+++ b/goil/templates/config/cortex-a/armv8/spider/interruptSources.oil
@@ -0,0 +1,43 @@
+/*
+ * Interrupt sources TO BE UPDATED
+ */
+ENUM [
+  /* ARM IRQs */
+  ARM_TIMER,              /* 0 */
+  ARM_MAILBOX,            /* 1 */
+  ARM_DOORBELL_0,         /* 2 */
+  ARM_DOORBELL_1,         /* 3 */
+  GPU0_HALTED,            /* 4 */
+  GPU1_HALTED,            /* 5 */
+  ILLEGAL_ACCESS_TYPE_1,  /* 6 */
+  ILLEGAL_ACCESS_TYPE_0,  /* 7 */
+  /* VC IRQs 0-31 */
+  /* IRQ pending source 31:0 */
+  AUX_INT,                /* 8 */
+  /* GPU IRQs 32-63 */
+  /* IRQ pending source 63:32 */
+  I2C_SPI_SLV_INT,        /* 9 */
+  PWA0,                   /* 10 */
+  PWA1,                   /* 11 */
+  SMI,                    /* 12 */
+  GPIO_INT_0,             /* 13 */
+  GPIO_INT_1,             /* 14 */
+  GPIO_INT_2,             /* 15 */
+  GPIO_INT_3,             /* 16 */
+  I2C_INT,                /* 17 */
+  SPI_INT,                /* 18 */
+  PCM_INT,                /* 19 */
+  UART_INT,               /* 20 */
+  /* Other GPU IRQs */
+  GPU_IRQ_7,              /* 21 */
+  GPU_IRQ_9,              /* 22 */
+  GPU_IRQ_10,             /* 23 */
+  GPU_IRQ_18,             /* 24 */
+  GPU_IRQ_19,             /* 25 */
+  GPU_IRQ_53,             /* 26 */
+  GPU_IRQ_54,             /* 27 */
+  GPU_IRQ_55,             /* 28 */
+  GPU_IRQ_56,             /* 29 */
+  GPU_IRQ_57,             /* 30 */
+  GPU_IRQ_62              /* 31 */
+] SOURCE;
diff --git a/goil/templates/config/cortex-a/armv8/spider/pins.oil b/goil/templates/config/cortex-a/armv8/spider/pins.oil
new file mode 100755
index 00000000..cfffbb4a
--- /dev/null
+++ b/goil/templates/config/cortex-a/armv8/spider/pins.oil
@@ -0,0 +1,2 @@
+ENUM [
+] PIN[];
diff --git a/goil/templates/linker/gnu_ld/cortex-a/armv8/spider/script.goilTemplate b/goil/templates/linker/gnu_ld/cortex-a/armv8/spider/script.goilTemplate
new file mode 100644
index 00000000..427f28ad
--- /dev/null
+++ b/goil/templates/linker/gnu_ld/cortex-a/armv8/spider/script.goilTemplate
@@ -0,0 +1,67 @@
+ OUTPUT_FORMAT("elf32-littlearm")
+_region_min_align = 4;
+
+ENTRY (_start)
+
+MEMORY
+{
+    FLASH (rx) : ORIGIN = 0x40040000, LENGTH = (0*1K - 0x0)
+    RAM (wx) : ORIGIN = 0x40040000, LENGTH = (32512 * 1K - 16 * 1K)
+   
+    IDT_LIST (wx) : ORIGIN = 0xFFFFF7FF, LENGTH = 2K
+}
+
+SECTIONS
+{
+  __rom_region_start = 0x40040000;
+  rom_start :
+  {
+    *(.vectbl)
+  } > RAM
+
+  .startup_code :
+  {
+    *(.startup_code)
+  } > RAM
+  .text :
+  {
+    *(.text*)
+  } > RAM
+
+  __bss_start = .;
+  .bss :
+  {
+    . = ALIGN(0x8);
+    __bss_start__ = .;
+    bss = .;
+    *(.bss)
+    __bss_end__ = .;
+  } > RAM
+
+  .stacks :
+  {
+    . = ALIGN(0x8);
+    __stacks_start = .;
+    . = . + 512; /* Size of FIQ stack */
+    __SP_fiq_ = .;
+    __SP_irq_bot_ = .;
+    . = . +1024; /* Size of IRQ stack */
+    __SP_irq_top_ = .;
+    . = . + 512; /* Size of MON stack */
+    __SP_mon_ = .;
+    . = . + 512; /* Size of UND stack */
+    __SP_und_ = .;
+    . = . + 512; /* Size of ABT stack */
+    __SP_abt_ = .;
+    __SP_svc_bot_ = .;
+    . = . + 512; /* Size of SVC stack */
+    __SP_svc_top_ = .;
+    . = . + 512; /* Size of HYP stack */
+    __SP_hyp_ = .;
+    __SP_usr_bot_ = .;
+    . = . + 1024; /* Size of USR and SYS stack */
+    __SP_usr_top_ = .;
+    __stacks_end = .;
+  } > RAM
+
+}
diff --git a/machines/cortex-a/armv8/spider/bootstrap_stage1.S b/machines/cortex-a/armv8/spider/bootstrap_stage1.S
new file mode 100644
index 00000000..902413dd
--- /dev/null
+++ b/machines/cortex-a/armv8/spider/bootstrap_stage1.S
@@ -0,0 +1,312 @@
+.extern __SP_fiq_
+.extern __SP_irq_
+.extern __SP_mon_
+.extern __SP_und_
+.extern __SP_abt_
+.extern __SP_svc_
+.extern __SP_hyp_
+.extern __SP_usr_
+
+#define ARM_MODE_BITS                         (0x0000001F)
+
+.section .startup_code, "ax"
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * _start
+ *
+ * _start is the first function called after a cpu reset.
+ * This function must be referenced in the link script with the keyword ENTRY:
+ * ENTRY(_start)
+ *
+ * At boot time the processor is in Supervisor mode and interrupts are
+ * disabled.
+ *
+ */
+.global _start
+_start:
+
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * startup
+ *
+ * startup function does the following steps:
+ * - Check start mode and switch to Supervisor Mode
+ * - Setup stacks
+ * - Switch the CPU to Secure Mode
+ * - Invalidate Caches
+ * - Invalidate TLB
+ * - Switch to System Mode
+ * - Copy the definitive Vector Table to RPI2_VECTOR_TABLE_BASE
+ * - Set the Vector Base Address register in the System Control
+ *
+ * @param
+ *
+ * None
+ *
+ */
+startup:
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * startupSwitchMode
+ *
+ * startupSwitchMode function tests the current mode of the cpu. If the mode
+ * is Hypervisor Mode then we switch to Supervisor Mode else we return.
+ * Switching to Supervisor Mode from Hypervisor Mode is explained in :
+ * B1.3.4 ELR_hyp
+ *
+ * @param
+ *
+ * None
+ *
+ */
+startupSwitchMode:
+  /* Get the CPSR */
+  mrs r0, cpsr
+  /* Test for HYP mode */
+  eor r0, r0, #0x1A /* #ARM_MODE_HYP */
+  tst r0, #0x1F /* #ARM_MODE_BITS */
+  /* Clear the mode bits */
+  bic r0, r0, #0x1F /* #ARM_MODE_BITS */
+  /* Mask IRQ/FIQ bits and set SVC mode */
+  orr r0, r0, #(0x80 | 0x40 | 0x13) /* #(ARM_I_BIT | ARM_F_BIT | ARM_MODE_SVC) */
+
+  /* Return if not in HYP mode */
+  bne startupSwitchMode_noSwitch
+
+  /* Init HSCTLR (Hyp System Control Register) */
+//  ldr r0, = #0x30C5181A //FSY (HSCTLR_RES1 | SCTLR_I_BIT | SCTLR_C_BIT)
+//  mcr p15, 4, r0, c1, c0, 0
+
+  /* Init HACTLR: Enable EL1 access to all IMP DEF registers */
+//  ldr r0, =HACTLR_INIT
+//  mcr p15, 4, r0, c1, c0, 1
+
+  /* Mask the Abort bit */
+  orr r0, r0, #0x100 /* #ARM_A_BIT */
+  /* Load the SPSR */
+  msr spsr_cxsf, r0
+  /* Return to SVC mode */
+
+  ldr r0, =setupStacks
+  msr elr_hyp, r0
+  dsb
+  isb
+  eret
+
+startupSwitchMode_noSwitch:
+  /* Set the CPSR (C fields) */
+  msr cpsr_c, r0
+
+
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * setupStacks
+ *
+ * setupStacks function initializes stacks:
+ * - __SP_fiq_top_ : not used, not initialized
+ * - __SP_irq_top_ :
+ * - __SP_mon_top_ : not used, not initialized
+ * - __SP_und_top_ :
+ * - __SP_abt_top_ :
+ * - __SP_svc_top_ :
+ * - __SP_hyp_top_ :
+ * - __SP_usr_top_ :
+ *
+ * @param
+ *
+ * None
+ *
+ */
+ setupStacks:
+  /* ldr r0, =__SP_fiq_ */
+  /* msr SP_fiq, r0 */
+  ldr r0, =__SP_irq_top_
+  msr SP_irq, r0
+  /* ldr r0, =__SP_mon_ */
+  /* msr SP_mon, r0 */
+  /* ldr r0, =__SP_und_ */
+  /* msr SP_und, r0 */
+  /* ldr r0, =__SP_abt_ */
+  /* msr SP_abt, r0 */
+  /*  SVC stack is initialized before */
+  ldr r0, =__SP_svc_top_
+  msr SP_svc, r0
+  /* ldr r0, =__SP_hyp_ */
+  /* msr SP_hyp, r0 */
+  ldr r0, =__SP_usr_top_
+  msr SP_usr, r0
+
+  /* Branch to second stage boot process */
+  b tpl_bootstrap_stage2
+
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * reset_handler
+ *
+ * @param
+ *
+ * None
+ *
+ */
+.global reset_handler
+reset_handler:
+  bx lr
+reset_handler_end:
+
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * undefined_handler
+ *
+ * @param
+ *
+ * None
+ *
+ */
+.global undefined_handler
+undefined_handler:
+  push {r0-r12, lr}
+  bl c_undefined_handler
+  pop {r0-r12, lr}
+  subs pc,lr,#4
+undefined_handler_end:
+
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * prefetch_handler
+ *
+ * @param
+ *
+ * None
+ *
+ */
+.global prefetch_handler
+prefetch_handler:
+  push {r0-r12, lr}
+  bl c_prefetch_handler
+  pop {r0-r12, lr}
+  subs pc,lr,#4
+prefetch_handler_end:
+
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * data_handler
+ *
+ * @param
+ *
+ * None
+ *
+ */
+.global data_handler
+data_handler:
+  push {r0-r12, lr}
+  bl c_data_handler
+  pop {r0-r12, lr}
+  subs pc,lr,#8
+data_handler_end:
+
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * reserved_handler
+ *
+ * @param
+ *
+ * None
+ *
+ */
+.global reserved_handler
+reserved_handler:
+  push {r0-r12, lr}
+  bl c_reserved_handler
+  pop {r0-r12, lr}
+  subs pc,lr,#4
+reserved_handler_end:
+
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * fiq_handler
+ *
+ * @param
+ *
+ * None
+ *
+ */
+.global fiq_handler
+fiq_handler:
+  push {r0-r12, lr}
+  bl c_fiq_handler
+  pop {r0-r12, lr}
+  subs pc,lr,#4
+fiq_handler_end:
+
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * smc_handler
+ *
+ * @param
+ *
+ * None
+ *
+ */
+.global smc_handler
+smc_handler:
+  //Cop_Read_SCR(r1)
+  bic r1, r1, #1
+  //Cop_Write_SCR(r1)
+  movs pc, lr
+smc_handler_end:
+
+/* ---------------------------------------------------------------- */
+/**
+ * @internal
+ *
+ * dummy
+ *
+ * @param
+ *
+ * None
+ *
+ */
+.global dummy
+dummy:
+  bx lr
+
+  /* ---------------------------------------------------------------- */
+  /**
+   * @internal
+   *
+   * enable_irq
+   *
+   * @param
+   *
+   * None
+   *
+   */
+.global enable_irq
+enable_irq:
+  mrs r0,cpsr
+  bic r0,r0,#0x80
+  msr cpsr_c,r0
+  bx lr
+enable_irq_end:
diff --git a/machines/cortex-a/armv8/spider/bootstrap_stage2.c b/machines/cortex-a/armv8/spider/bootstrap_stage2.c
new file mode 100644
index 00000000..84d0eb09
--- /dev/null
+++ b/machines/cortex-a/armv8/spider/bootstrap_stage2.c
@@ -0,0 +1,65 @@
+/**
+ * @file bootstrap_stage2.c
+ *
+ * @section descr File description
+ *
+ * Second part of the bootstrap for Spider board
+ *
+ * @section copyright Copyright
+ *
+ * Trampoline OS
+ *
+ * Trampoline is copyright (c) IRCCyN 2005+
+ * Copyright ESEO for function and data structures documentation and ARM port
+ * Trampoline is protected by the French intellectual property law.
+ *
+ * This software is distributed under the Lesser GNU Public Licence
+ *
+ * @section infos File informations
+ *
+ * $Date$
+ * $Rev$
+ * $Author$
+ * $URL$
+ */
+ #include "tpl_os.h"
+
+extern int main (void);
+
+#define OS_START_SEC_CODE
+#include "tpl_memmap.h"
+
+// Begin address for the .bss section; defined in linker script
+extern unsigned int __bss_start__;
+// End address for the .bss section; defined in linker script
+extern unsigned int __bss_end__;
+
+inline void __attribute__((always_inline))
+bss_init(unsigned int* section_begin, unsigned int* section_end)
+{
+  // Iterate and clear word by word.
+  // It is assumed that the pointers are word aligned.
+  unsigned int *p = section_begin;
+  while (p < section_end)
+    *p++ = 0;
+}
+
+/* this function should not return as
+ * it is called straight after reset
+ */
+void tpl_bootstrap_stage2 ()
+{
+    /* Zero fill the bss segment */
+    bss_init(&__bss_start__, &__bss_end__);
+
+    /*
+     * start application (which may start Trampoline via StartOS)
+     */
+    main ();
+
+    /* ends in a loop, as we should not return from "reset call" */
+    while (1);
+}
+
+#define OS_STOP_SEC_CODE
+#include "tpl_memmap.h"
diff --git a/machines/cortex-a/armv8/spider/handlers_spider.c b/machines/cortex-a/armv8/spider/handlers_spider.c
new file mode 100644
index 00000000..2fcafb66
--- /dev/null
+++ b/machines/cortex-a/armv8/spider/handlers_spider.c
@@ -0,0 +1,68 @@
+/**
+ * Spider platform specific handlers
+ *
+ * @section copyright Copyright
+ *
+ * Trampoline OS
+ *
+ * Trampoline is copyright (c) IRCCyN 2005+
+ * Copyright DG for function and data structures documentation and THUMB2 port
+ * Trampoline is protected by the French intellectual property law.
+ *
+ * This software is distributed under the Lesser GNU Public Licence
+ *
+ * @section infos File informations
+ *
+ * $Date$
+ * $Rev$
+ * $Author$
+ * $URL$
+ */
+
+#include "handlers_spider.h"
+
+/******************************************************************************
+ * Exception handlers.
+ ******************************************************************************/
+
+FUNC(void, OS_CODE) c_undefined_handler(void) {
+  while(1);
+}
+
+FUNC(void, OS_CODE) c_prefetch_handler(void) {
+  while(1);
+}
+
+FUNC(void, OS_CODE) c_data_handler(void) {
+  while(1);
+}
+
+FUNC(void, OS_CODE)  c_reserved_handler(void) {
+  while(1);
+}
+
+FUNC(void, OS_CODE) c_fiq_handler(void) {
+  while(1);
+}
+
+FUNC(void, OS_CODE) c_irq_handler(void) {
+	while(1);
+}
+
+FUNC(void, OS_CODE) c_svc_handler(void) {
+	while(1);
+}
+
+FUNC(void, OS_CODE) c_hang_handler(void) {
+  while(1);
+}
+
+/******************************************************************************
+ * IRQ acknowledge functions.
+ ******************************************************************************/
+FUNC(void, OS_CODE) ARM_TIMER_ClearFlag(void) {
+	/* 
+	 * Clear the ARM Timer interrupt
+	 */
+	//FSY writeToReg(ARM_TIMER_CLI,0);
+}
diff --git a/machines/cortex-a/armv8/spider/handlers_spider.h b/machines/cortex-a/armv8/spider/handlers_spider.h
new file mode 100644
index 00000000..79a8371f
--- /dev/null
+++ b/machines/cortex-a/armv8/spider/handlers_spider.h
@@ -0,0 +1,35 @@
+/**
+ * @section descr File description
+ *
+ * Spider platform specific handlers
+ *
+ * @section copyright Copyright
+ *
+ * Trampoline OS
+ *
+ * Trampoline is copyright (c) IRCCyN 2005+
+ * Copyright DG for function and data structures documentation and THUMB2 port
+ * Trampoline is protected by the French intellectual property law.
+ *
+ * This software is distributed under the Lesser GNU Public Licence
+ *
+ * @section infos File informations
+ *
+ * $Date$
+ * $Rev$
+ * $Author$
+ * $URL$
+ */
+
+#include "tpl_os.h"
+#include "tpl_os_interrupt_kernel.h"
+#include "emblib.h"
+
+/******************************************************************************
+ * Exception handlers.
+ ******************************************************************************/
+
+/******************************************************************************
+ * IRQ acknowledge functions.
+ ******************************************************************************/
+FUNC(void, OS_CODE) ARM_TIMER_ClearFlag(void);
diff --git a/machines/cortex-a/armv8/spider/tpl_irq.c b/machines/cortex-a/armv8/spider/tpl_irq.c
new file mode 100644
index 00000000..122faec5
--- /dev/null
+++ b/machines/cortex-a/armv8/spider/tpl_irq.c
@@ -0,0 +1,56 @@
+/**
+ * @section descr File description
+ *
+ * Spider platform irq handling
+ *
+ * @section copyright Copyright
+ *
+ * Trampoline OS
+ *
+ * Trampoline is copyright (c) IRCCyN 2005+
+ * Copyright ESEO for function and data structures documentation and ARM port
+ * Trampoline is protected by the French intellectual property law.
+ *
+ * This software is distributed under the Lesser GNU Public Licence
+ *
+ * @section infos File informations
+ *
+ * $Date$
+ * $Rev$
+ * $Author$
+ * $URL$
+ */
+
+#include "tpl_os.h"
+#include "tpl_os_interrupt_kernel.h"
+#include "emblib.h"
+
+extern CONST(tpl_it_vector_entry, OS_CONST) tpl_it_vector[31];
+
+static inline uint32 cp15_read_irq_id(void)
+{
+    uint32 irq_id;
+    __asm__ volatile
+    (
+        "mrc p15, 0, %[result], c12, c8, 0;"
+        :[result] "=r" (irq_id)::"memory"
+    );
+
+    return irq_id;
+}
+
+
+void tpl_arm_subarch_irq_handler ()
+{
+  VAR(uint32, AUTOMATIC) isr_id_dec;
+  VAR(tpl_it_handler, AUTOMATIC) isr_vector;
+
+  /*
+   * get interrupt id
+   */
+  isr_id_dec = cp15_read_irq_id();
+
+  /* launch interrupt fonction */
+  isr_vector = tpl_it_vector[isr_id_dec].func;
+  isr_vector(tpl_it_vector[isr_id_dec].args);
+}
diff --git a/machines/cortex-a/armv8/spider/tpl_machine_spider.c b/machines/cortex-a/armv8/spider/tpl_machine_spider.c
new file mode 100644
index 00000000..602e071b
--- /dev/null
+++ b/machines/cortex-a/armv8/spider/tpl_machine_spider.c
@@ -0,0 +1,110 @@
+/**
+ * @file tpl_machine_spider.c
+ *
+ * @section descr File description
+ *
+ * Trampoline processor dependant functions.
+ *
+ * @section copyright Copyright
+ *
+ * Trampoline RTOS
+ *
+ * Trampoline is copyright (c) CNRS, University of Nantes, Ecole Centrale de Nantes
+ * Trampoline is protected by the French intellectual property law.
+ *
+ * This software is distributed under the GNU Public Licence V2.
+ * Check the LICENSE file in the root directory of Trampoline
+ *
+ * @section infos File informations
+ *
+ * $Date$
+ * $Rev$
+ * $Author$
+ * $URL$
+ */
+
+#include "tpl_compiler.h"
+#include "tpl_os_std_types.h"
+#include "tpl_machine.h"
+#include "emblib.h"
+
+#define OS_START_SEC_CODE
+#include "tpl_memmap.h"
+
+#define CNTV_CTL_ENABLE   1
+#define CNTV_CTL_IMASK    2
+
+#define NB_TICK	((uint64)12500000 / (uint64)100) // systick 100 times per seconds (every 10ms)
+
+inline uint32 __attribute__((always_inline)) CNTV_CTL_read(void) {
+    uint32 val;
+    cp15_read32(0, 14, 3, 1, val);
+    return val;
+}
+
+inline void __attribute__((always_inline)) CNTV_CTL_write(uint32 val) {
+    cp15_write32(0, 14, 3, 1, val);
+}
+
+inline uint64 __attribute__((always_inline)) CNTV_VAL_read(void) {
+    uint32 val;
+    cp15_read64(3, 14, val);
+    return val;
+}
+
+inline void __attribute__((always_inline)) CNTV_VAL_write(uint64 val) {
+    cp15_write64(3, 14, val);
+}
+
+inline uint64 __attribute__((always_inline)) CNTVCT_read(void) {
+    uint32 val;
+    cp15_read64(1, 14, val);
+    return val;
+}
+
+inline void __attribute__((always_inline))
+enable_systick_timer(unsigned char enable) {
+
+	uint64 cntv_ctl;
+
+	cntv_ctl = CNTV_CTL_read();
+
+	if (enable) {
+		cntv_ctl |= CNTV_CTL_ENABLE;
+	} else {
+		cntv_ctl &= ~CNTV_CTL_ENABLE;
+	}
+
+	CNTV_CTL_write(cntv_ctl);
+}
+
+inline uint64 __attribute__((always_inline))
+get_systick_timer() {
+
+	return CNTVCT_read();
+
+}
+
+//interrupt id #27
+FUNC(void, OS_CODE) tpl_set_systick_timer(void) {
+    enable_systick_timer(0);
+
+    writeToAddress(0xf0110180, 0xffffffff); // Clear pending interrupts
+    writeToAddress(0xf0110080, 0xffffffff); // GICR_IGROUPR0: set to group 1=IRQ (group0=FIQ)
+    writeToAddress(0xf0110100, 0xffffffff); // GICR_ISENABLER0: enable forwarding int to cpu
+    writeToAddress(0xf0000000, 0x53); //GICD_CTLR: enable interrupts distribution to CPU
+
+    cp15_write32(0, 12, 12, 6, 1); // Write 1 to ICC_IGRPEN0
+    cp15_write32(0, 12, 12, 7, 1); // Write 1 to ICC_IGRPEN1
+
+    __asm__ volatile ("CPSIE IF");
+
+    CNTV_VAL_write(get_systick_timer() + NB_TICK); // can set CNTV_TVAL
+    enable_systick_timer(1);
+
+    /* Unmask interrupt */
+    CNTV_CTL_write(CNTV_CTL_read() & ~CNTV_CTL_IMASK);
+
+}
+#define OS_STOP_SEC_CODE
+#include "tpl_memmap.h"
diff --git a/machines/cortex-a/armv8/spider/tpl_stacks_size.h b/machines/cortex-a/armv8/spider/tpl_stacks_size.h
new file mode 100644
index 00000000..af76808d
--- /dev/null
+++ b/machines/cortex-a/armv8/spider/tpl_stacks_size.h
@@ -0,0 +1,40 @@
+/**
+ * @file tpl_stacks_size.h
+ *
+ * @section descr File description
+ *
+ * Trampoline standard types. Here for MISRA rule 13 compliance
+ * and for platform specific type definition
+ *
+ * @section copyright Copyright
+ *
+ * Trampoline OS
+ *
+ * Trampoline is copyright (c) IRCCyN 2005+
+ * Copyright ESEO for function and data structures documentation and ARM port
+ * Trampoline is protected by the French intellectual property law.
+ *
+ * This software is distributed under the Lesser GNU Public Licence
+ *
+ * @section infos File informations
+ *
+ * $Date$
+ * $Rev$
+ * $Author$
+ * $URL$
+ */
+
+#ifndef TPL_OS_STACKS_SIZE_H
+#define TPL_OS_STACKS_SIZE_H
+
+#define IRQ_STACK_SIZE 256*4
+#define FIQ_STACK_SIZE 256*4
+#define SVC_STACK_SIZE 512*4
+#define ABT_STACK_SIZE 256*4
+#define UND_STACK_SIZE 256*4
+#define USR_STACK_SIZE 256*4
+
+#endif /* TPL_OS_STACKS_SIZE_H */
+
+/* End of file tpl_stacks_size.h */
+
diff --git a/machines/cortex-a/armv8/spider/tpl_stubs.c b/machines/cortex-a/armv8/spider/tpl_stubs.c
new file mode 100644
index 00000000..af060b22
--- /dev/null
+++ b/machines/cortex-a/armv8/spider/tpl_stubs.c
@@ -0,0 +1,62 @@
+/**
+ * @file tpl_stubs.c
+ *
+ * @section descr File description
+ *
+ * Spider platform specific routines and variables
+ *
+ * @section copyright Copyright
+ *
+ * Trampoline OS
+ *
+ * Trampoline is copyright (c) IRCCyN 2005+
+ * Copyright ESEO for function and data structures documentation and ARM port
+ * Trampoline is protected by the French intellectual property law.
+ *
+ * This software is distributed under the Lesser GNU Public Licence
+ *
+ * @section infos File informations
+ *
+ * $Date$
+ * $Rev$
+ * $Author$
+ * $URL$
+ */
+#include "tpl_machine.h"
+#include "tpl_machine_arm.h"
+#include "tpl_machine_interface.h"
+#include "tpl_os_definitions.h"
+#include "tpl_os_kernel.h"
+
+#include "emblib.h"
+extern unsigned int GETISR ( void );
+
+// #include "init.h"
+extern void enable_irq ( void );
+
+#define OS_START_SEC_CODE
+#include "tpl_memmap.h"
+
+extern uint32 vectors;
+
+FUNC(void, OS_CODE) tpl_init_machine(void)
+{
+    cp15_write32(0, 12, 0, 0, &vectors);  // write VBAR
+
+    tpl_init_machine_generic ();
+
+    //enable_irq();
+}
+
+FUNC(void, OS_CODE) tpl_shutdown(void)
+{
+    /* FIXME: this is does not conform to AUTOSAR OS specifications,
+     * should return to main with initial context */
+    DISABLE_FIQ ();
+    DISABLE_IRQ ();
+
+    while (1);
+}
+
+#define OS_STOP_SEC_CODE
+#include "tpl_memmap.h"
diff --git a/machines/cortex-a/armv8/spider/tpl_vector_table_ns.s b/machines/cortex-a/armv8/spider/tpl_vector_table_ns.s
new file mode 100644
index 00000000..f0b46188
--- /dev/null
+++ b/machines/cortex-a/armv8/spider/tpl_vector_table_ns.s
@@ -0,0 +1,30 @@
+
+;@ ------------------------------------------------------------------
+;@ ------------------------------------------------------------------
+
+.section .vectbl, "ax"
+.code 32
+.align 2
+
+@.align 4
+.global vectors
+vectors:
+  ldr pc,vectors_reset_address
+  ldr pc,vectors_undefined_address
+  ldr pc,vectors_svc_address
+  ldr pc,vectors_prefetch_address
+  ldr pc,vectors_data_address
+  ldr pc,vectors_reserved_address
+  ldr pc,vectors_irq_address
+  ldr pc,vectors_undefined_address
+vectors_reset_address:      .word reset_handler
+vectors_undefined_address:  .word undefined_handler
+vectors_svc_address:        .word tpl_primary_syscall_handler
+vectors_prefetch_address:   .word prefetch_handler
+vectors_data_address:       .word data_handler
+vectors_reserved_address:   .word reserved_handler
+vectors_irq_address:        .word tpl_primary_irq_handler
+vectors_fiq_address:        .word fiq_handler
+vectors_end:
+
+.ltorg
-- 
2.34.1

